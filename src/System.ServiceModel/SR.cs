using System;
using System.Globalization;

static partial class SR
{
	internal static string Format (string name, params object[] args)
	{
		return Format (CultureInfo.InvariantCulture, name, args);
	}

	internal static string Format (CultureInfo culture, string name, params object[] args)
	{
		return string.Format (culture, name, args);
	}

	internal static string Format (string name)
	{
		return name;
	}

	internal static string Format (CultureInfo culture, string name)
	{
		return name;
	}
}

static partial class SR
{
	public const string NoIPEndpointsFoundForHost="No IPEndpoints were found for host {0}.";
	public const string DnsResolveFailed="No DNS entries exist for host {0}.";
	public const string RequiredAttributeMissing="Attribute '{0}' is required on element '{1}'.";
	public const string UnsupportedCryptoAlgorithm="Crypto algorithm {0} not supported in this context.";
	public const string CustomCryptoAlgorithmIsNotValidHashAlgorithm="The custom crypto algorithm '{0}' obtained using CryptoConfig is not a valid or supported hash algorithm.";
	public const string InvalidClientCredentials="The client credential entered was invalid.";
	public const string SspiErrorOrInvalidClientCredentials="Either the client credential was invalid or there was an error collecting the client credentials by the SSPI.";
	public const string CustomCryptoAlgorithmIsNotValidAsymmetricSignature="The custom crypto algorithm '{0}' obtained using CryptoConfig is not a valid or supported asymmetric signature algorithm.";
	public const string TokenSerializerNotSetonFederationProvider="The security token serializer must be specified on the security token provider.";
	public const string IssuerBindingNotPresentInTokenRequirement="The key length '{0}' is not a multiple of 8 for symmetric keys.";
	public const string IssuerChannelBehaviorsCannotContainSecurityCredentialsManager="The channel behaviors configured for the issuer address '{0}' cannot contain a behavior of type '{1}'.";
	public const string ServiceBusyCountTrace="Operation Action={0}";
	public const string SecurityTokenManagerCannotCreateProviderForRequirement="The security token manager cannot create a token provider for requirement '{0}'.";
	public const string SecurityTokenManagerCannotCreateAuthenticatorForRequirement="The security token manager cannot create a token authenticator for requirement '{0}'.";
	public const string FailedSignatureVerification="The signature verification failed. Please see inner exception for fault details.";
	public const string SecurityTokenManagerCannotCreateSerializerForVersion="The security token manager cannot create a token serializer for security token version '{0}'.";
	public const string SupportingSignatureIsNotDerivedFrom="The supporting signature is not signed with a derived key. The binding's supporting token parameter '{0}' requires key derivation.";
	public const string PrimarySignatureWasNotSignedByDerivedKey="The primary signature is not signed with a derived key. The binding's primary token parameter '{0}' requires key derivation.";
	public const string PrimarySignatureWasNotSignedByDerivedWrappedKey="The primary signature is not signed with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.";
	public const string MessageWasNotEncryptedByDerivedWrappedKey="The message is not encrypted with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.";
	public const string SecurityStateEncoderDecodingFailure="The DataProtectionSecurityStateEncoder is unable to decode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.";
	public const string SecurityStateEncoderEncodingFailure="The DataProtectionSecurityStateEncoder is unable to encode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.";
	public const string MessageWasNotEncryptedByDerivedEncryptionToken="The message is not encrypted with a key derived from the encryption token. The binding's token parameter '{0}' requires key derivation.";
	public const string TokenAuthenticatorRequiresSecurityBindingElement="The security token manager requires the security binding element to be specified in order to create a token authenticator for requirement '{0}'.";
	public const string TokenProviderRequiresSecurityBindingElement="The security token manager requires the security binding element to be specified in order to create a token provider for requirement '{0}'.";
	public const string UnexpectedSecuritySessionCloseResponse="The security session received an unexpected close response from the other party.";
	public const string UnexpectedSecuritySessionClose="The security session received an unexpected close from the other party.";
	public const string CannotObtainSslConnectionInfo="The service was unable to verify the cipher strengths negotiated as part of the SSL handshake.";
	public const string HeaderEncryptionNotSupportedInWsSecurityJan2004="SecurityVersion.WSSecurityJan2004 does not support header encryption. Header with name '{0}' and namespace '{1}' is configured for encryption. Consider using SecurityVersion.WsSecurity11 and above or use transport security to encrypt the full message.";
	public const string EncryptedHeaderNotSigned="The Header ('{0}', '{1}') was encrypted but not signed. All encrypted headers outside the security header should be signed.";
	public const string EncodingBindingElementDoesNotHandleReaderQuotas="Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty<T>() method.";
	public const string HeaderDecryptionNotSupportedInWsSecurityJan2004="SecurityVersion.WSSecurityJan2004 does not support header decryption. Use SecurityVersion.WsSecurity11 and above or use transport security to encrypt the full message.";
	public const string DecryptionFailed="Unable to decrypt an encrypted data block. Please verify that the encryption algorithm and keys used by the sender and receiver match.";
	public const string AuthenticationManagerShouldNotReturnNull="The authenticate method in the ServiceAuthenticationManager returned null. If you do not want to return any authorization policies in the collection then return an empty ReadOnlyCollection instead. ";
	public const string ErrorSerializingSecurityToken="There was an error serializing the security token. Please see the inner exception for more details.";
	public const string ErrorDeserializingKeyIdentifierClauseFromTokenXml="There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.";
	public const string ErrorDeserializingTokenXml="There was an error deserializing the security token XML. Please see the inner exception for more details.";
	public const string TokenRequirementDoesNotSpecifyTargetAddress="The token requirement '{0}' does not specify the target address. This is required by the token manager for creating the corresponding security token provider.";
	public const string DerivedKeyNotInitialized="The derived key has not been computed for the security token.";
	public const string IssuedKeySizeNotCompatibleWithAlgorithmSuite="The binding ('{0}', '{1}') has been configured with a security algorithm suite '{2}' that is incompatible with the issued token key size '{3}' specified on the binding.";
	public const string IssuedTokenAuthenticationModeRequiresSymmetricIssuedKey="The IssuedToken security authentication mode requires the issued token to contain a symmetric key.";
	public const string InvalidBearerKeyUsage="The binding ('{0}', '{1}') uses an Issued Token with Bearer Key Type in a invalid context. The Issued Token with a Bearer Key Type can only be used as a Signed Supporting token or a Signed Encrypted Supporting token. See the SecurityBindingElement.EndpointSupportingTokenParameters property.";
	public const string MultipleIssuerEndpointsFound="Policy for multiple issuer endpoints was retrieved from '{0}' but the relying party's policy does not specify which issuer endpoint to use. One of the endpoints was selected as the issuer endpoint to use. If you are using svcutil, the other endpoints will be available in commented form in the configuration as <alternativeIssuedTokenParameters>. Check the configuration to ensure that the right issuer endpoint was selected.";
	public const string MultipleAuthenticationManagersInServiceBindingParameters="The AuthenticationManager cannot be added to the binding parameters because the binding parameters already contains a AuthenticationManager '{0}'. If you are configuring a custom AuthenticationManager for the service, please first remove any existing AuthenticationManagers from the behaviors collection before adding the custom AuthenticationManager.";
	public const string MultipleAuthenticationSchemesInServiceBindingParameters="The AuthenticationSchemes cannot be added to the binding parameters because the binding parameters already contains AuthenticationSchemes '{0}'. If you are configuring custom AuthenticationSchemes for the service, please first remove any existing AuthenticationSchemes from the behaviors collection before adding custom AuthenticationSchemes.";
	public const string NoSecurityBindingElementFound="Unable to find a SecurityBindingElement.";
	public const string MultipleSecurityCredentialsManagersInServiceBindingParameters="The ServiceCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the service, please first remove any existing ServiceCredentials from the behaviors collection before adding the custom credential.";
	public const string MultipleSecurityCredentialsManagersInChannelBindingParameters="The ClientCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the channel, please first remove any existing ClientCredentials from the behaviors collection before adding the custom credential.";
	public const string NoClientCertificate="The binding ('{0}', '{1}') has been configured with a MutualCertificateDuplexBindingElement that requires a client certificate. The client certificate is currently missing.";
	public const string SecurityTokenParametersHasIncompatibleInclusionMode="The binding ('{0}', '{1}') is configured with a security token parameter '{2}' that has an incompatible security token inclusion mode '{3}'. Specify an alternate security token inclusion mode (for example, '{4}').";
	public const string CannotCreateTwoWayListenerForNegotiation="Unable to create a bi-directional (request-reply or duplex) channel for security negotiation. Please ensure that the binding is capable of creating a bi-directional channel.";
	public const string NegotiationQuotasExceededFaultReason="There are too many active security negotiations or secure conversations at the service. Please retry later.";
	public const string PendingSessionsExceededFaultReason="There are too many pending secure conversations on the server. Please retry later.";
	public const string RequestSecurityTokenDoesNotMatchEndpointFilters="The RequestSecurityToken message does not match the endpoint filters the service '{0}' is expecting incoming messages to match. This may be because the RequestSecurityToken was intended to be sent to a different service.";
	public const string SecuritySessionRequiresIssuanceAuthenticator="The security session requires a security token authenticator that implements '{0}'. '{1}' does not implement '{0}'.";
	public const string SecuritySessionRequiresSecurityContextTokenCache="The security session requires a security token resolver that implements '{1}'. The security token resolver '{0}' does not implement '{1}'.";
	public const string SessionTokenIsNotSecurityContextToken="The session security token authenticator returned a token of type '{0}'. The token type expected is '{1}'.";
	public const string SessionTokenIsNotGenericXmlToken="The session security token provider returned a token of type '{0}'. The token type expected is '{1}'.";
	public const string SecurityStandardsManagerNotSet="The security standards manager was not specified on  '{0}'.";
	public const string SecurityNegotiationMessageTooLarge="The security negotiation message with action '{0}' is larger than the maximum allowed buffer size '{1}'. If you are using a streamed transport consider increasing the maximum buffer size on the transport.";
	public const string PreviousChannelDemuxerOpenFailed="The channel demuxer Open failed previously with exception '{0}'.";
	public const string SecurityChannelListenerNotSet="The security channel listener was not specified on  '{0}'.";
	public const string SecurityChannelListenerChannelExtendedProtectionNotSupported="ExtendedProtectionPolicy specified a PolicyEnforcement of 'Always' which is not supported for the authentication mode requested.  This prevents the ExtendedProtectionPolicy from being enforced. For StandardBindings use a SecurityMode of TransportWithMessageCredential and a ClientCredential type of Windows. For CustomBindings use SspiNegotiationOverTransport or KerberosOverTransport.  Alternatively, specify a PolicyEnforcement of 'Never'.";
	public const string SecurityChannelBindingMissing="ExtendedProtectionPolicy specified a PolicyEnforcement of 'Always' and a ChannelBinding was not found.  This prevents the ExtendedProtectionPolicy from being enforced. Change the binding to make a ChannelBinding available, for StandardBindings use a SecurityMode of TransportWithMessageCredential and a ClientCredential type of Windows. For CustomBindings use SspiNegotiationOverTransport or KerberosOverTransport.  Alternatively, specify a PolicyEnforcement of 'Never'.";
	public const string SecuritySettingsLifetimeManagerNotSet="The security settings lifetime manager was not specified on  '{0}'.";
	public const string SecurityListenerClosing="The listener is not accepting new secure conversations because it is closing.";
	public const string SecurityListenerClosingFaultReason="The server is not accepting new secure conversations currently because it is closing. Please retry later.";
	public const string SslCipherKeyTooSmall="The cipher key negotiated by SSL is too small ('{0}' bits). Keys of such lengths are not allowed as they may result in information disclosure. Please configure the initiator machine to negotiate SSL cipher keys that are '{1}' bits or longer.";
	public const string DerivedKeyTokenNonceTooLong="The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.";
	public const string DerivedKeyTokenLabelTooLong="The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.";
	public const string DerivedKeyTokenOffsetTooHigh="The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.";
	public const string DerivedKeyTokenGenerationAndLengthTooHigh="The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.";
	public const string DerivedKeyLimitExceeded="The number of derived keys in the message has exceeded the maximum allowed number '{0}'.";
	public const string WrappedKeyLimitExceeded="The number of encrypted keys in the message has exceeded the maximum allowed number '{0}'.";
	public const string BufferQuotaExceededReadingBase64="Unable to finish reading Base64 data as the given buffer quota has been exceeded. Buffer quota: {0}. Consider increasing the MaxReceivedMessageSize quota on the TransportBindingElement. Please note that a very high value for MaxReceivedMessageSize will result in buffering a large message and might open the system to DOS attacks.";
	public const string MessageSecurityDoesNotWorkWithManualAddressing="Manual addressing is not supported with message level security. Configure the binding ('{0}', '{1}') to use transport security or to not do manual addressing.";
	public const string TargetAddressIsNotSet="The target service address was not specified on '{0}'.";
	public const string IssuedTokenCacheNotSet="The issued token cache was not specified on '{0}'.";
	public const string SecurityAlgorithmSuiteNotSet="The security algorithm suite was not specified on '{0}'.";
	public const string SecurityTokenFoundOutsideSecurityHeader="A security token ('{0}', '{1}') was found outside the security header. The message may have been altered in transit.";
	public const string SecurityTokenNotResolved="The SecurityTokenProvider '{0}' could not resolve the token.";
	public const string SecureConversationCancelNotAllowedFaultReason="A secure conversation cancellation is not allowed by the binding.";
	public const string BootstrapSecurityBindingElementNotSet="The security binding element for bootstrap security was not specified on '{0}'.";
	public const string IssuerBuildContextNotSet="The context for building the issuer channel was  not specified on '{0}'.";
	public const string StsBindingNotSet="The binding to use to communicate to the federation service at '{0}' is not specified.";
	public const string SslCertMayNotDoKeyExchange="It is likely that certificate '{0}' may not have a private key that is capable of key exchange or the process may not have access rights for the private key. Please see inner exception for detail.";
	public const string SslCertMustHavePrivateKey="The certificate '{0}' must have a private key. The process must have access rights for the private key.";
	public const string NoOutgoingEndpointAddressAvailableForDoingIdentityCheck="No outgoing EndpointAddress is available to check the identity on a message to be sent.";
	public const string NoOutgoingEndpointAddressAvailableForDoingIdentityCheckOnReply="No outgoing EndpointAddress is available to check the identity on a received reply.";
	public const string NoSigningTokenAvailableToDoIncomingIdentityCheck="No signing token is available to do an incoming identity check.";
	public const string Psha1KeyLengthInvalid="The PSHA1 key length '{0}' is invalid.";
	public const string CloneNotImplementedCorrectly="Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.";
	public const string BadIssuedTokenType="The issued token is of unexpected type '{0}'. Expected token type '{1}'.";
	public const string OperationDoesNotAllowImpersonation="The service operation '{0}' that belongs to the contract with the '{1}' name and the '{2}' namespace does not allow impersonation.";
	public const string RstrHasMultipleIssuedTokens="The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.";
	public const string RstrHasMultipleProofTokens="The RequestSecurityTokenResponse has multiple RequestedProofToken elements.";
	public const string ProofTokenXmlUnexpectedInRstr="The proof token XML element is not expected in the response.";
	public const string InvalidKeyLengthRequested="The key length '{0}' requested is invalid.";
	public const string IssuedSecurityTokenParametersNotSet="The security token parameters to use for the issued token are not set on '{0}'.";
	public const string InvalidOrUnrecognizedAction="The message could not be processed because the action '{0}' is invalid or unrecognized.";
	public const string UnsupportedTokenInclusionMode="Token inclusion mode '{0}' is not supported.";
	public const string CannotImportProtectionLevelForContract="The policy to import a process cannot import a binding for contract ({0},{1}). The protection requirements for the binding are not compatible with a binding already imported for the contract. You must reconfigure the binding.";
	public const string OnlyOneOfEncryptedKeyOrSymmetricBindingCanBeSelected="The symmetric security protocol can either be configured with a symmetric token provider and a symmetric token authenticator or an asymmetric token provider. It cannot be configured with both.";
	public const string ClientCredentialTypeMustBeSpecifiedForMixedMode="ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.";
	public const string SecuritySessionIdAlreadyPresentInFilterTable="The security session id '{0}' is already present in the filter table.";
	public const string SupportingTokenNotProvided="A supporting token that satisfies parameters '{0}' and attachment mode '{1}' was not provided.";
	public const string SupportingTokenIsNotEndorsing="The supporting token provided for parameters '{0}' did not endorse the primary signature.";
	public const string SupportingTokenIsNotSigned="The supporting token provided for parameters '{0}' was not signed as part of the primary signature.";
	public const string SupportingTokenIsNotEncrypted="The supporting token provided for parameters '{0}' was not encrypted.";
	public const string BasicTokenNotExpected="A basic token is not expected in the security header in this context.";
	public const string FailedAuthenticationTrustFaultCode="The request for security token could not be satisfied because authentication failed.";
	public const string AuthenticationOfClientFailed="The caller was not authenticated by the service.";
	public const string InvalidRequestTrustFaultCode="The request for security token has invalid or malformed elements.";
	public const string SignedSupportingTokenNotExpected="A signed supporting token is not expected in the security header in this context.";
	public const string SenderSideSupportingTokensMustSpecifySecurityTokenParameters="Security token parameters must be specified with supporting tokens for each message.";
	public const string SignatureAndEncryptionTokenMismatch="The signature token '{0}' is not the same token as the encryption token '{1}'.";
	public const string RevertingPrivilegeFailed="The reverting operation failed with the exception '{0}'.";
	public const string UnknownSupportingToken="Unrecognized supporting token '{0}' was encountered.";
	public const string MoreThanOneSupportingSignature="More than one supporting signature was encountered using the same supporting token '{0}'.";
	public const string UnsecuredMessageFaultReceived="An unsecured or incorrectly secured fault was received from the other party. See the inner FaultException for the fault code and detail.";
	public const string FailedAuthenticationFaultReason="At least one security token in the message could not be validated.";
	public const string BadContextTokenOrActionFaultReason="The message could not be processed. This is most likely because the action '{0}' is incorrect or because the message contains an invalid or expired security context token or because there is a mismatch between bindings. The security context token would be invalid if the service aborted the channel due to inactivity. To prevent the service from aborting idle sessions prematurely increase the Receive timeout on the service endpoint's binding.";
	public const string BadContextTokenFaultReason="The security context token is expired or is not valid. The message was not processed.";
	public const string NegotiationFailedIO="Transport security negotiation failed due to an underlying IO error: {0}.";
	public const string SecurityNegotiationCannotProtectConfidentialEndpointHeader="The security negotiation with '{0}' cannot be initiated because the confidential endpoint address header ('{1}', '{2}') cannot be encrypted during the course of the negotiation.";
	public const string InvalidSecurityTokenFaultReason="An error occurred when processing the security tokens in the message.";
	public const string InvalidSecurityFaultReason="An error occurred when verifying security for the message.";
	public const string AnonymousLogonsAreNotAllowed="The service does not allow you to log on anonymously.";
	public const string UnableToObtainIssuerMetadata="Obtaining metadata from issuer '{0}' failed with error '{1}'.";
	public const string ErrorImportingIssuerMetadata="Importing metadata from issuer '{0}' failed with error '{1}'.";
	public const string MultipleCorrelationTokensFound="Multiple correlation tokens were found in the security correlation state.";
	public const string NoCorrelationTokenFound="No correlation token was found in the security correlation state.";
	public const string MultipleSupportingAuthenticatorsOfSameType="Multiple supporting token authenticators with the token parameter type equal to '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.";
	public const string TooManyIssuedSecurityTokenParameters="A leg of the federated security chain contains multiple IssuedSecurityTokenParameters. The InfoCard system only supports one IssuedSecurityTokenParameters for each leg.";
	public const string UnknownTokenAuthenticatorUsedInTokenProcessing="An unrecognized token authenticator '{0}' was used for token processing.";
	public const string TokenMustBeNullWhenTokenParametersAre="The SecurityTokenParameters and SecurityToken tuple specified for use in the security header must both be null or must both be non-null.";
	public const string SecurityTokenParametersCloneInvalidResult="The CloneCore method of {0} type returned an invalid result. ";
	public const string CertificateUnsupportedForHttpTransportCredentialOnly="Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.";
	public const string BasicHttpMessageSecurityRequiresCertificate="BasicHttp binding requires that BasicHttpBinding.Security.Message.ClientCredentialType be equivalent to the BasicHttpMessageCredentialType.Certificate credential type for secure messages. Select Transport or TransportWithMessageCredential security for UserName credentials.";
	public const string EntropyModeRequiresRequestorEntropy="The client must provide key entropy in key entropy mode '{0}'.";
	public const string BearerKeyTypeCannotHaveProofKey="A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.";
	public const string BearerKeyIncompatibleWithWSFederationHttpBinding="Bearer Key Type is not supported with WSFederationHttpBinding. Please use WS2007FederationHttpBinding.";
	public const string UnableToCreateKeyTypeElementForUnknownKeyType="Unable to create Key Type element for the Key Type '{0}'. This might be due to a wrong version of MessageSecurityVersion set on the SecurityBindingElement.";
	public const string EntropyModeCannotHaveProofTokenOrIssuerEntropy="The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.";
	public const string EntropyModeCannotHaveRequestorEntropy="The client cannot provide key entropy in key entropy mode '{0}'.";
	public const string EntropyModeRequiresProofToken="The issuer must provide a proof token in key entropy mode '{0}'.";
	public const string EntropyModeRequiresComputedKey="The issuer must provide a computed key in key entropy mode '{0}'.";
	public const string EntropyModeRequiresIssuerEntropy="The issuer must provide key entropy in key entropy mode '{0}'.";
	public const string EntropyModeCannotHaveComputedKey="The issuer cannot provide a computed key in key entropy mode '{0}'.";
	public const string UnknownComputedKeyAlgorithm="The computed key algorithm '{0}' is not supported.";
	public const string NoncesCachedInfinitely="The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.";
	public const string ChannelMustBeOpenedToGetSessionId="The session channel must be opened before the session ID can be accessed.";
	public const string SecurityVersionDoesNotSupportEncryptedKeyBinding="The binding ('{0}','{1}') for contract ('{2}','{3}') has been configured with an incompatible security version that does not support unattached references to EncryptedKeys. Use '{4}' or higher as the security version for the binding.";
	public const string SecurityVersionDoesNotSupportThumbprintX509KeyIdentifierClause="The '{0}','{1}' binding for the '{2}','{3}' contract is configured with a security version that does not support external references to X.509 tokens using the certificate's thumbprint value. Use '{4}' or higher as the security version for the binding.";
	public const string SecurityBindingSupportsOneWayOnly="The SecurityBinding for the ('{0}','{1}') binding for the ('{2}','{3}') contract only supports the OneWay operation.";
	public const string DownlevelNameCannotMapToUpn="Cannot map Windows user '{0}' to a UserPrincipalName that can be used for S4U impersonation.";
	public const string ResolvingExternalTokensRequireSecurityTokenParameters="Resolving an External reference token requires appropriate SecurityTokenParameters to be specified.";
	public const string SecurityRenewFaultReason="The SecurityContextSecurityToken's key needs to be renewed.";
	public const string ClientSecurityOutputSessionCloseTimeout="The client's security session was not able to close its output session within the configured timeout ({0}).";
	public const string ClientSecurityNegotiationTimeout="Client is unable to finish the security negotiation within the configured timeout ({0}).  The current negotiation leg is {1} ({2}).  ";
	public const string ClientSecuritySessionRequestTimeout="Client is unable to request the security session within the configured timeout ({0}).";
	public const string ServiceSecurityCloseOutputSessionTimeout="The service's security session was not able to close its output session within the configured timeout ({0}).";
	public const string ServiceSecurityCloseTimeout="The service's security session did not receive a 'close' message from the client within the configured timeout ({0}).";
	public const string ClientSecurityCloseTimeout="The client's security session did not receive a 'close response' message from the service within the configured timeout ({0}).";
	public const string UnableToRenewSessionKey="Cannot renew the security session key.";
	public const string SessionKeyRenewalNotSupported="Cannot renew the security session key. Session Key Renewal is not supported.";
	public const string SctCookieXmlParseError="Error parsing SecurityContextSecurityToken Cookie XML.";
	public const string SctCookieValueMissingOrIncorrect="The SecurityContextSecurityToken's Cookie element either does not contain '{0}' or has a wrong value for it.";
	public const string SctCookieBlobDecodeFailure="Error decoding the Cookie element of SecurityContextSecurityToken.";
	public const string SctCookieNotSupported="Issuing cookie SecurityContextSecurityToken is not supported.";
	public const string CannotImportSupportingTokensForOperationWithoutRequestAction="Security policy import failed. The security policy contains supporting token requirements at the operation scope. The contract description does not specify the action for the request message associated with this operation.";
	public const string SignatureConfirmationsNotExpected="Signature confirmation is not expected in the security header.";
	public const string SignatureConfirmationsOccursAfterPrimarySignature="The signature confirmation elements cannot occur after the primary signature.";
	public const string SignatureConfirmationWasExpected="Signature confirmation was expected to be present in the security header.";
	public const string SecurityVersionDoesNotSupportSignatureConfirmation="The SecurityVersion '{0}' does not support signature confirmation. Use a later SecurityVersion.";
	public const string SignatureConfirmationRequiresRequestReply="The protocol factory must support Request/Reply security in order to offer signature confirmation.";
	public const string NotAllSignaturesConfirmed="Not all the signatures in the request message were confirmed in the reply message.";
	public const string FoundUnexpectedSignatureConfirmations="The request did not have any signatures but the reply has signature confirmations.";
	public const string TooManyPendingSessionKeys="There are too many renewed session keys that have not been used.";
	public const string SecuritySessionKeyIsStale="The session key must be renewed before it can secure application messages.";
	public const string MultipleMatchingCryptosFound="The token's crypto collection has multiple objects of type '{0}'.";
	public const string CannotFindMatchingCrypto="The token's crypto collection does not support algorithm '{0}'.";
	public const string SymmetricSecurityBindingElementNeedsProtectionTokenParameters="SymmetricSecurityBindingElement cannot build a channel or listener factory. The ProtectionTokenParameters property is required but not set. Binding element configuration: {0}";
	public const string AsymmetricSecurityBindingElementNeedsInitiatorTokenParameters="AsymmetricSecurityBindingElement cannot build a channel or listener factory. The InitiatorTokenParameters property is required but not set. Binding element configuration: {0}";
	public const string AsymmetricSecurityBindingElementNeedsRecipientTokenParameters="AsymmetricSecurityBindingElement cannot build a channel or listener factory. The RecipientTokenParameters property is required but not set. Binding element configuration: {0}";
	public const string CachedNegotiationStateQuotaReached="The service cannot cache the negotiation state as the capacity '{0}' has been reached. Retry the request.";
	public const string LsaAuthorityNotContacted="Internal SSL error (refer to Win32 status code for details). Check the server certificate to determine if it is capable of key exchange.";
	public const string KeyRolloverGreaterThanKeyRenewal="The key rollover interval cannot be greater than the key renewal interval.";
	public const string AtLeastOneContractOperationRequestRequiresProtectionLevelNotSupportedByBinding="The request message must be protected. This is required by an operation of the contract ('{0}','{1}'). The protection must be provided by the binding ('{2}','{3}').";
	public const string AtLeastOneContractOperationResponseRequiresProtectionLevelNotSupportedByBinding="The response message must be protected. This is required by an operation of the contract ('{0}', '{1}'). The protection must be provided by the binding ('{2}', '{3}').";
	public const string UnknownHeaderCannotProtected="The contract ('{0}','{1}') contains some unknown header ('{2}','{3}') which cannot be secured. Please choose ProtectionLevel.None for this header.   ";
	public const string NoStreamingWithSecurity="The binding ('{0}','{1}') supports streaming which cannot be configured together with message level security.  Consider choosing a different transfer mode or choosing the transport level security.";
	public const string CurrentSessionTokenNotRenewed="The supporting token in the renew message has a different generation '{0}' than the current session token's generation '{1}'.";
	public const string IncorrectSpnOrUpnSpecified="Security Support Provider Interface (SSPI) authentication failed. The server may not be running in an account with identity '{0}'. If the server is running in a service account (Network Service for example), specify the account's ServicePrincipalName as the identity in the EndpointAddress for the server. If the server is running in a user account, specify the account's UserPrincipalName as the identity in the EndpointAddress for the server.";
	public const string IncomingSigningTokenMustBeAnEncryptedKey="For this security protocol, the incoming signing token must be an EncryptedKey.";
	public const string SecuritySessionAbortedFaultReason="The security session was terminated This may be because no messages were received on the session for too long.";
	public const string NoAppliesToPresent="No AppliesTo element is present in the deserialized RequestSecurityToken/RequestSecurityTokenResponse.";
	public const string UnsupportedKeyLength="Symmetric Key length {0} is not supported by the algorithm suite '{1}'.";
	public const string ForReplayDetectionToBeDoneRequireIntegrityMustBeSet="For replay detection to be done ProtectionLevel must be Sign or EncryptAndSign.";
	public const string CantInferReferenceForToken="Can't infer an external reference for '{0}' token type.";
	public const string TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences="Unable to create Attached or Unattached reference for '{0}'.";
	public const string TrustDriverVersionDoesNotSupportSession="The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.";
	public const string TrustDriverVersionDoesNotSupportIssuedTokens="The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.";
	public const string CannotPerformS4UImpersonationOnPlatform="The binding ('{0}','{1}') for contract ('{2}','{3}') supports impersonation only on Windows 2003 Server and newer version of Windows. Use SspiNegotiated authentication and a binding with Secure Conversation with cancellation enabled.";
	public const string CannotPerformImpersonationOnUsernameToken="Impersonation using the client token is not possible. The binding ('{0}', '{1}') for contract ('{2}', '{3}') uses the Username Security Token for client authentication with a Membership Provider registered. Use a different type of security token for the client.";
	public const string RevertImpersonationFailure="Failed to revert impersonation. {0}";
	public const string TransactionFlowRequiredIssuedTokens="In order to flow a transaction, flowing issued tokens must also be supported.";
	public const string SignatureConfirmationNotSupported="The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.";
	public const string SecureConversationDriverVersionDoesNotSupportSession="The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.";
	public const string SoapSecurityNegotiationFailed="SOAP security negotiation failed. See inner exception for more details.";
	public const string SoapSecurityNegotiationFailedForIssuerAndTarget="SOAP security negotiation with '{0}' for target '{1}' failed. See inner exception for more details.";
	public const string OneWayOperationReturnedFault="The one-way operation returned a fault message.  The reason for the fault was '{0}'.";
	public const string OneWayOperationReturnedLargeFault="The one-way operation returned a fault message with Action='{0}'.";
	public const string OneWayOperationReturnedMessage="The one-way operation returned a non-null message with Action='{0}'.";
	public const string CannotFindSecuritySession="Cannot find the security session with the ID '{0}'.";
	public const string SecurityContextKeyExpired="The SecurityContextSecurityToken with Context-id={0} (generation-id={1}) has expired.";
	public const string SecurityContextKeyExpiredNoKeyGeneration="The SecurityContextSecurityToken with Context-id={0} (no key generation-id) has expired.";
	public const string SecuritySessionRequiresMessageIntegrity="Security sessions require all messages to be signed.";
	public const string RequiredTimestampMissingInSecurityHeader="Required timestamp missing in security header.";
	public const string ReceivedMessageInRequestContextNull="The request message in the request context received from channel '{0}' is null.";
	public const string KeyLifetimeNotWithinTokenLifetime="The key effective and expiration times must be bounded by the token effective and expiration times.";
	public const string EffectiveGreaterThanExpiration="The valid from time is greater than the valid to time.";
	public const string NoSessionTokenPresentInMessage="No session token was present in the message.";
	public const string LengthMustBeGreaterThanZero="The length of this argument must be greater than 0.";
	public const string KeyLengthMustBeMultipleOfEight="Key length '{0}' is not a multiple of 8 for symmetric keys.";
	public const string InvalidX509RawData="Invalid binary representation of an X.509 certificate.";
	public const string ExportOfBindingWithTransportSecurityBindingElementAndNoTransportSecurityNotSupported="Security policy export failed. The binding contains a TransportSecurityBindingElement but no transport binding element that implements ITransportTokenAssertionProvider. Policy export for such a binding is not supported. Make sure the transport binding element in the binding implements the ITransportTokenAssertionProvider interface.";
	public const string UnsupportedSecureConversationBootstrapProtectionRequirements="Cannot import the security policy. The protection requirements for the secure conversation bootstrap binding are not supported. Protection requirements for the secure conversation bootstrap must require both the request and the response to be signed and encrypted.";
	public const string UnsupportedBooleanAttribute="Cannot import the policy. The value of the attribute '{0}' must be either 'true', 'false', '1' or '0'. The following error occurred: '{1}'.";
	public const string NoTransportTokenAssertionProvided="The security policy expert failed. The provided transport token assertion of type '{0}' did not create a transport token assertion to include the sp:TransportBinding security policy assertion.";
	public const string PolicyRequiresConfidentialityWithoutIntegrity="Message security policy for the '{0}' action requires confidentiality without integrity. Confidentiality without integrity is not supported.";
	public const string PrimarySignatureIsRequiredToBeEncrypted="The primary signature must be encrypted.";
	public const string TokenCannotCreateSymmetricCrypto="A symmetric crypto could not be created from token '{0}'.";
	public const string TokenDoesNotMeetKeySizeRequirements="The key size requirements for the '{0}' algorithm suite are not met by the '{1}' token which has key size of '{2}'.";
	public const string MessageProtectionOrderMismatch="The received message does not meet the required message protection order '{0}'.";
	public const string PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures="Primary signature must be computed before supporting token signatures.";
	public const string ElementToSignMustHaveId="Element to sign must have id.";
	public const string StandardsManagerCannotWriteObject="The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.";
	public const string SigningWithoutPrimarySignatureRequiresTimestamp="Signing without primary signature requires timestamp.";
	public const string OperationCannotBeDoneAfterProcessingIsStarted="This operation cannot be done after processing is started.";
	public const string MaximumPolicyRedirectionsExceeded="The recursive policy fetching limit has been reached. Check to determine if there is a loop in the federation service chain.";
	public const string InvalidAttributeInSignedHeader="The ('{0}', '{1}') signed header contains the ('{2}', '{3}') attribute. The expected attribute is ('{4}', '{5}').";
	public const string StsAddressNotSet="The address of the security token issuer is not specified. An explicit issuer address must be specified in the binding for target '{0}' or the local issuer address must be configured in the credentials.";
	public const string MoreThanOneSecurityBindingElementInTheBinding="More than one SecurityBindingElement found in the binding ('{0}', '{1}) for contract ('{2}', '{3}'). Only one SecurityBindingElement is allowed. ";
	public const string ClientCredentialsUnableToCreateLocalTokenProvider="ClientCredentials cannot create a local token provider for token requirement {0}.";
	public const string SecurityBindingElementCannotBeExpressedInConfig="A security policy was imported for the endpoint. The security policy contains requirements that cannot be represented in a Windows Communication Foundation configuration. Look for a comment about the SecurityBindingElement parameters that are required in the configuration file that was generated. Create the correct binding element with code. The binding configuration that is in the configuration file is not secure.";
	public const string SecurityProtocolCannotDoReplayDetection="The security protocol '{0}' cannot do replay detection.";
	public const string UnableToFindSecurityHeaderInMessage="Security processor was unable to find a security header with actor '{0}' in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.  This can occur if the service is configured for security and the client is not using security.";
	public const string UnableToFindSecurityHeaderInMessageNoActor="Security processor was unable to find a security header in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.   This can occur if the service is configured for security and the client is not using security.";
	public const string NoPrimarySignatureAvailableForSupportingTokenSignatureVerification="No primary signature available for supporting token signature verification.";
	public const string SupportingTokenSignaturesNotExpected="Supporting token signatures not expected.";
	public const string CannotReadToken="Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.";
	public const string ExpectedElementMissing="Element '{0}' with namespace '{1}' not found.";
	public const string ExpectedOneOfTwoElementsFromNamespace="Expected element '{0}' or element '{1}' (from namespace '{2}').";
	public const string RstDirectDoesNotExpectRstr="AcceleratedTokenAuthenticator does not expect RequestSecurityTokenResponse from the client.";
	public const string RequireNonCookieMode="The '{0}' binding with the '{1}' namespace is configured to issue cookie security context tokens. COM+ Integration services does not support cookie security context tokens.";
	public const string RequiredSignatureMissing="The signature must be in the security header.";
	public const string RequiredMessagePartNotSigned="The '{0}' required message part was not signed.";
	public const string RequiredMessagePartNotSignedNs="The '{0}', '{1}' required message part  was not signed.";
	public const string RequiredMessagePartNotEncrypted="The '{0}' required message part was not encrypted.";
	public const string RequiredMessagePartNotEncryptedNs="The '{0}', '{1}' required message part  was not encrypted.";
	public const string SignatureVerificationFailed="Signature verification failed.";
	public const string CannotIssueRstTokenType="Cannot issue the token type '{0}'.";
	public const string NoNegotiationMessageToSend="There is no negotiation message to send.";
	public const string InvalidIssuedTokenKeySize="The issued token has an invalid key size '{0}'.";
	public const string CannotObtainIssuedTokenKeySize="Cannot determine the key size of the issued token.";
	public const string NegotiationIsNotCompleted="The negotiation has not yet completed.";
	public const string NegotiationIsCompleted="The negotiation has already completed.";
	public const string MissingMessageID="Request Message is missing a MessageID header. One is required to correlate a reply.";
	public const string SecuritySessionLimitReached="Cannot create a security session. Retry later.";
	public const string SecuritySessionAlreadyPending="The security session with id '{0}' is already pending.";
	public const string SecuritySessionNotPending="No security session with id '{0}' is pending.";
	public const string SecuritySessionListenerNotFound="No security session listener was found for message with action '{0}'.";
	public const string SessionTokenWasNotClosed="The session token was not closed by the server.";
	public const string ProtocolMustBeInitiator="'{0}' protocol can only be used by the Initiator.";
	public const string ProtocolMustBeRecipient="'{0}' protocol can only be used at the Recipient.";
	public const string SendingOutgoingmessageOnRecipient="Unexpected code path for server security application, sending outgoing message on Recipient.";
	public const string OnlyBodyReturnValuesSupported="Only body return values are supported currently for protection, MessagePartDescription was specified.";
	public const string UnknownTokenAttachmentMode="Unknown token attachment mode: {0}.";
	public const string ProtocolMisMatch="Security protocol must be '{0}', type is: '{1}'.;";
	public const string AttemptToCreateMultipleRequestContext="The initial request context was already specified.  Can not create two for same message.";
	public const string ServerReceivedCloseMessageStateIsCreated="{0}.OnCloseMessageReceived when state == Created.";
	public const string ShutdownRequestWasNotReceived="Shutdown request was not received.";
	public const string UnknownFilterType="Unknown filter type: '{0}'.";
	public const string StandardsManagerDoesNotMatch="Standards manager of filter does not match that of filter table.  Can not have two different filters.";
	public const string FilterStrictModeDifferent="Session filter's isStrictMode differs from filter table's isStrictMode.";
	public const string SSSSCreateAcceptor="SecuritySessionServerSettings.CreateAcceptor, channelAcceptor must be null, can not create twice.";
	public const string TransactionFlowBadOption="Invalid TransactionFlowOption value.";
	public const string TokenManagerCouldNotReadToken="Security token manager could not parse token with name '{0}', namespace '{1}', valueType '{2}'.";
	public const string InvalidActionForNegotiationMessage="Security negotiation message has incorrect action '{0}'.";
	public const string InvalidKeySizeSpecifiedInNegotiation="The specified key size {0} is invalid. The key size must be between {1} and {2}.";
	public const string GetTokenInfoFailed="Could not get token information (error=0x{0:X}).";
	public const string UnexpectedEndOfFile="Unexpected end of file.";
	public const string TimeStampHasCreationAheadOfExpiry="The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').";
	public const string TimeStampHasExpiryTimeInPast="The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.";
	public const string TimeStampHasCreationTimeInFuture="The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.";
	public const string TimeStampWasCreatedTooLongAgo="The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.";
	public const string InvalidOrReplayedNonce="The nonce is invalid or replayed.";
	public const string MessagePartSpecificationMustBeImmutable="Message part specification must be made constant before being set.";
	public const string UnsupportedIssuerEntropyType="Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.";
	public const string NoRequestSecurityTokenResponseElements="No RequestSecurityTokenResponse elements were found.";
	public const string NoCookieInSct="The SecurityContextSecurityToken does not have a cookie.";
	public const string TokenProviderReturnedBadToken="TokenProvider returned token of incorrect type '{0}'.";
	public const string ItemNotAvailableInDeserializedRST="{0} is not available in deserialized RequestSecurityToken.";
	public const string ItemAvailableInDeserializedRSTOnly="{0} is only available in a deserialized RequestSecurityToken.";
	public const string ItemNotAvailableInDeserializedRSTR="{0} is not available in deserialized RequestSecurityTokenResponse.";
	public const string ItemAvailableInDeserializedRSTROnly="{0} is only available in a deserialized RequestSecurityTokenResponse.";
	public const string MoreThanOneRSTRInRSTRC="The RequestSecurityTokenResponseCollection received has more than one RequestSecurityTokenResponse element. Only one RequestSecurityTokenResponse element was expected.";
	public const string Hosting_VirtualPathExtenstionCanNotBeDetached="VirtualPathExtension is not allowed to be removed.";
	public const string Hosting_NotSupportedProtocol="The protocol '{0}' is not supported.";
	public const string Hosting_BaseUriDeserializedNotValid="The BaseUriWithWildcard object has invalid fields after deserialization.";
	public const string Hosting_RelativeAddressFormatError="Registered relativeAddress '{0}' in configuration file is not a valid one. Possible causes could be : You specified an empty addreess or an absolute address (i.e., starting with '/' or '\\'), or the address contains invalid character[s]. The supported relativeAddress formats are \"[folder/]filename\" or \"~/[folder/]filename\".  ";
	public const string Hosting_NoAbsoluteRelativeAddress=" '{0}' is an absolute address. The supported relativeAddress formats are \"[subfolder/]filename\" or \"~/[subfolder/]filename\".  ";
	public const string SecureConversationNeedsBootstrapSecurity="Cannot create security binding element based on the configuration data. When secure conversation authentication mode is selected, the secure conversation bootstrap binding element must also be specified. ";
	public const string Hosting_MemoryGatesCheckFailedUnderPartialTrust="Setting minFreeMemoryPercentageToActivateService requires full trust privilege. Please change the application's trust level or remove this setting from the configuration file.";
	public const string Hosting_CompatibilityServiceNotHosted="This service requires ASP.NET compatibility and must be hosted in IIS.  Either host the service in IIS with ASP.NET compatibility turned on in web.config or set the AspNetCompatibilityRequirementsAttribute.AspNetCompatibilityRequirementsMode property to a value other than Required.";
	public const string Hosting_MisformattedPort="The '{0}' protocol binding '{1}' specifies an invalid port number '{2}'.";
	public const string Hosting_MisformattedBinding="The protocol binding '{0}' does not conform to the syntax for '{1}'. The following is an example of valid '{1}' protocol bindings: '{2}'.";
	public const string Hosting_MisformattedBindingData="The protocol binding '{0}' is not valid for '{1}'.  This might be because the port number is out of range.";
	public const string Hosting_NoHttpTransportManagerForUri="There is no compatible TransportManager found for URI '{0}'. This may be because you have used an absolute address that points outside of the virtual application. Please use a relative address instead.";
	public const string Hosting_NoTcpPipeTransportManagerForUri="There is no compatible TransportManager found for URI '{0}'. This may be because you have used an absolute address that points outside of the virtual application, or the binding settings of the endpoint do not match those that have been set by other services or endpoints. Note that all bindings for the same protocol should have the same settings in the same application.";
	public const string Hosting_ProcessNotExecutingUnderHostedContext="'{0}' cannot be invoked within the current hosting environment. This API requires that the calling application be hosted in IIS or WAS.";
	public const string Hosting_ServiceActivationFailed="The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.";
	public const string Hosting_ServiceTypeNotProvided="The value for the Service attribute was not provided in the ServiceHost directive.";
	public const string SharedEndpointReadDenied="The service endpoint failed to listen on the URI '{0}' because access was denied.  Verify that the current user is granted access in the appropriate allowAccounts section of SMSvcHost.exe.config.";
	public const string SharedEndpointReadNotFound="The service endpoint failed to listen on the URI '{0}' because the shared memory section was not found.  Verify that the '{1}' service is running.";
	public const string SharedManagerBase="The TransportManager failed to listen on the supplied URI using the {0} service: {1}.";
	public const string SharedManagerServiceStartFailure="failed to start the service ({0}). Refer to the Event Log for more details";
	public const string SharedManagerServiceStartFailureDisabled="failed to start the service because it is disabled. An administrator can enable it by running 'sc.exe config {0} start= demand'.";
	public const string SharedManagerServiceStartFailureNoError="failed to start the service. Refer to the Event Log for more details";
	public const string SharedManagerServiceLookupFailure="failed to look up the service process in the SCM ({0})";
	public const string SharedManagerServiceSidLookupFailure="failed to look up the service SID in the SCM ({0})";
	public const string SharedManagerServiceEndpointReadFailure="failed to read the service's endpoint with native error code {0}.  See inner exception for details";
	public const string SharedManagerServiceSecurityFailed="the service failed the security checks";
	public const string SharedManagerUserSidLookupFailure="failed to retrieve the UserSid of the service process ({0})";
	public const string SharedManagerCurrentUserSidLookupFailure="failed to retrieve the UserSid of the current process";
	public const string SharedManagerLogonSidLookupFailure="failed to retrieve the LogonSid of the service process ({0})";
	public const string SharedManagerDataConnectionFailure="failed to establish a data connection to the service";
	public const string SharedManagerDataConnectionCreateFailure="failed to create a data connection to the service";
	public const string SharedManagerDataConnectionPipeFailed="failed to establish the data connection because of an I/O error";
	public const string SharedManagerVersionUnsupported="the version is not supported by the service";
	public const string SharedManagerAllowDupHandleFailed="failed to grant the PROCESS_DUP_HANDLE access right to the target service's account SID '{0}'.";
	public const string SharedManagerPathTooLong="the URI is too long";
	public const string SharedManagerRegistrationQuotaExceeded="the quota was exceeded";
	public const string SharedManagerProtocolUnsupported="the protocol is not supported";
	public const string SharedManagerConflictingRegistration="the URI is already registered with the service";
	public const string SharedManagerFailedToListen="the service failed to listen";
	public const string Sharing_ConnectionDispatchFailed="The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details";
	public const string Sharing_EndpointUnavailable="The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.";
	public const string Sharing_EmptyListenerEndpoint="The endpoint address for the NT service '{0}' read from shared memory is empty.";
	public const string Sharing_ListenerProxyStopped="The message could not be dispatched because the transport manager has been stopped.  This can happen if the application is being recycled or disabled.";
	public const string UnexpectedEmptyElementExpectingClaim="The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim. ";
	public const string UnexpectedElementExpectingElement="'{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'";
	public const string UnexpectedDuplicateElement="'{0}' from namespace '{1}' is not expected to appear more than once";
	public const string UnsupportedSecurityPolicyAssertion="An unsupported security policy assertion was detected during the security policy import: {0}";
	public const string MultipleIdentities="The extensions cannot contain an Identity if one is supplied as a constructor argument.";
	public const string InvalidUriValue="Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.";
	public const string BindingDoesNotSupportProtectionForRst="The binding ('{0}','{1}') for contract ('{2}','{3}') is configured with SecureConversation, but the authentication mode is not able to provide the request/reply-based integrity and confidentiality required for the negotiation.";
	public const string TransportDoesNotProtectMessage="The '{0}'.'{1}' binding for the '{2}'.'{3}' contract is configured with an authentication mode that requires transport level integrity and confidentiality. However the transport cannot provide integrity and confidentiality.";
	public const string BindingDoesNotSupportWindowsIdenityForImpersonation="The contract operation '{0}' requires Windows identity for automatic impersonation. A Windows identity that represents the caller is not provided by binding ('{1}','{2}') for contract ('{3}','{4}'.";
	public const string ListenUriNotSet="A listen URI must be specified in order to open this {0}.";
	public const string UnsupportedChannelInterfaceType="Channel interface type '{0}' is not supported.";
	public const string TransportManagerOpen="This property cannot be changed after the transport manager has been opened.";
	public const string TransportManagerNotOpen="This operation is only valid after the transport manager has been opened.";
	public const string UnrecognizedIdentityType="Unrecognized identity type Name='{0}', Namespace='{1}'.";
	public const string InvalidIdentityElement="Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.";
	public const string UnableToLoadCertificateIdentity="Cannot load the X.509 certificate identity specified in the configuration.";
	public const string UnrecognizedClaimTypeForIdentity="The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.";
	public const string AsyncCallbackException="An AsyncCallback threw an exception.";
	public const string SendCannotBeCalledAfterCloseOutputSession="You cannot Send messages on a channel after CloseOutputSession has been called.";
	public const string CommunicationObjectCannotBeModifiedInState="The communication object, {0}, cannot be modified while it is in the {1} state.";
	public const string CommunicationObjectCannotBeModified="The communication object, {0}, cannot be modified unless it is in the Created state.";
	public const string CommunicationObjectCannotBeUsed="The communication object, {0}, is in the {1} state.  Communication objects cannot be used for communication unless they are in the Opened state.";
	public const string CommunicationObjectFaulted1="The communication object, {0}, cannot be used for communication because it is in the Faulted state.";
	public const string CommunicationObjectFaultedStack2="The communication object, {0}, cannot be used for communication because it is in the Faulted state: {1}";
	public const string CommunicationObjectAborted1="The communication object, {0}, cannot be used for communication because it has been Aborted.";
	public const string CommunicationObjectAbortedStack2="The communication object, {0}, cannot be used for communication because it has been Aborted: {1}";
	public const string CommunicationObjectBaseClassMethodNotCalled="The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.";
	public const string CommunicationObjectInInvalidState="The communication object, {0}, is not part of WCF and is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that communication object.";
	public const string CommunicationObjectCloseInterrupted1="The communication object, {0}, cannot be used due to an error that occurred during close.";
	public const string ChannelFactoryCannotBeUsedToCreateChannels="A call to IChannelFactory.CreateChannel made on an object of type {0} failed because Open has not been called on this object.";
	public const string ChannelParametersCannotBeModified="Cannot modify channel parameters because the {0} is in the {1} state.  This operation is only supported in the Created state.";
	public const string ChannelParametersCannotBePropagated="Cannot propagate channel parameters because the {0} is in the {1} state.  This operation is only supported in the Opening or Opened state when the collection is locked.";
	public const string OneWayInternalTypeNotSupported="Binding '{0}' is not configured properly. OneWayBindingElement requires an inner binding element that supports IRequestChannel/IReplyChannel or IDuplexSessionChannel. ";
	public const string ChannelTypeNotSupported="The specified channel type {0} is not supported by this channel manager.";
	public const string SecurityContextMissing="SecurityContext for the UltimateReceiver role is missing from the SecurityContextProperty of the request message with action '{0}'.";
	public const string SecurityContextDoesNotAllowImpersonation="Cannot start impersonation because the SecurityContext for the UltimateReceiver role from the request message with the '{0}' action is not mapped to a Windows identity.";
	public const string InvalidEnumValue="Unexpected internal enum value: {0}.";
	public const string InvalidDecoderStateMachine="Invalid decoder state machine.";
	public const string OperationPropertyIsRequiredForAttributeGeneration="Operation property of OperationAttributeGenerationContext is required to generate an attribute based on settings. ";
	public const string InvalidMembershipProviderSpecifiedInConfig="The username/password Membership provider {0} specified in the configuration is invalid. No such provider was found registered under system.web/membership/providers.";
	public const string InvalidRoleProviderSpecifiedInConfig="The RoleProvider {0} specified in the configuration is invalid. No such provider was found registered under system.web/roleManager/providers.";
	public const string ObjectDisposed="The {0} object has been disposed.";
	public const string InvalidReaderPositionOnCreateMessage="The XmlReader used for the body of the message must be positioned on an element.";
	public const string DuplicateMessageProperty="A property with the name '{0}' already exists.";
	public const string MessagePropertyNotFound="A property with the name '{0}' is not present.";
	public const string HeaderAlreadyUnderstood="The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.";
	public const string HeaderAlreadyNotUnderstood="The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.";
	public const string MultipleMessageHeaders="Multiple headers with name '{0}' and namespace '{1}' found.";
	public const string MultipleMessageHeadersWithActor="Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.";
	public const string MultipleRelatesToHeaders=" Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.";
	public const string ExtraContentIsPresentInFaultDetail="Additional XML content is present in the fault detail element. Only a single element is allowed.";
	public const string MessageIsEmpty="The body of the message cannot be read because it is empty.";
	public const string MessageClosed="Message is closed.";
	public const string StreamClosed="The operation cannot be completed because the stream is closed.";
	public const string BodyWriterReturnedIsNotBuffered="The body writer returned from OnCreateBufferedCopy was not buffered.";
	public const string BodyWriterCanOnlyBeWrittenOnce="The body writer does not support writing more than once because it is not buffered.";
	public const string RstrKeySizeNotProvided="KeySize element not present in RequestSecurityTokenResponse.";
	public const string RequestMessageDoesNotHaveAMessageID="A reply message cannot be created because the request message does not have a MessageID.";
	public const string HeaderNotFound="There is not a header with name {0} and namespace {1} in the message.";
	public const string MessageBufferIsClosed="MessageBuffer is closed.";
	public const string MessageTextEncodingNotSupported="The text encoding '{0}' used in the text message format is not supported.";
	public const string AtLeastOneFaultReasonMustBeSpecified="At least one fault reason must be specified.";
	public const string NoNullTranslations="The translation set cannot contain nulls.";
	public const string FaultDoesNotHaveAnyDetail="The fault does not have detail information.";
	public const string InvalidXmlQualifiedName="Expected XML qualified name, found '{0}'.";
	public const string UnboundPrefixInQName="Unbound prefix used in qualified name '{0}'.";
	public const string MessageBodyIsUnknown="...";
	public const string MessageBodyIsStream="... stream ...";
	public const string MessageBodyToStringError="... Error reading body: {0}: {1} ...";
	public const string NoMatchingTranslationFoundForFaultText="The fault reason does not contain any text translations.";
	public const string CannotDetermineSPNBasedOnAddress="Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\\alice) or SPN identity (like host/bobs-machine).";
	public const string XmlLangAttributeMissing="Required xml:lang attribute value is missing.";
	public const string EncoderUnrecognizedCharSet="Unrecognized charSet '{0}' in contentType.";
	public const string EncoderUnrecognizedContentType="Unrecognized contentType ({0}). Expected: {1}.";
	public const string EncoderBadContentType="Cannot process contentType.";
	public const string EncoderEnvelopeVersionMismatch="The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.";
	public const string EncoderMessageVersionMismatch="The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.";
	public const string MtomEncoderBadMessageVersion="MessageVersion '{0}' not supported by MTOM encoder.";
	public const string SPS_ReadNotSupported="Read is not supported on this stream.";
	public const string SPS_SeekNotSupported="Seek is not supported on this stream.";
	public const string WriterAsyncWritePending="An asynchronous write is pending on the stream. Ensure that there are no uncompleted asynchronous writes before attempting the next write. ";
	public const string ChannelInitializationTimeout="A newly accepted connection did not receive initialization data from the sender within the configured ChannelInitializationTimeout ({0}).  As a result, the connection will be aborted.  If you are on a highly congested network, or your sending machine is heavily loaded, consider increasing this value or load-balancing your server.";
	public const string SocketCloseReadTimeout="The remote endpoint of the socket ({0}) did not respond to a close request within the allotted timeout ({1}). It is likely that the remote endpoint is not calling Close after receiving the EOF signal (null) from Receive. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string SocketCloseReadReceivedData="A graceful close was attempted on the socket, but the other side ({0}) is still sending data.";
	public const string SessionValueInvalid="The Session value '{0}' is invalid. Please specify 'CurrentSession','ServiceSession' or a valid non-negative Windows Session Id.";
	public const string PackageFullNameInvalid="The package full name '{0}' is invalid.";
	public const string SocketAbortedReceiveTimedOut="The socket was aborted because an asynchronous receive from the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string SocketAbortedSendTimedOut="The socket connection was aborted because an asynchronous send to the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string OperationInvalidBeforeSecurityNegotiation="This operation is not valid until security negotiation is complete.";
	public const string FramingError="Error while reading message framing format at position {0} of stream (state: {1})";
	public const string FramingPrematureEOF="More data was expected, but EOF was reached.";
	public const string FramingRecordTypeMismatch="Expected record type '{0}', found '{1}'.";
	public const string FramingVersionNotSupported="Framing major version {0} is not supported.";
	public const string FramingModeNotSupported="Framing mode {0} is not supported.";
	public const string FramingSizeTooLarge="Specified size is too large for this implementation.";
	public const string FramingViaTooLong="The framing via size ({0}) exceeds the quota.";
	public const string FramingViaNotUri="The framing via ({0}) is not a valid URI.";
	public const string FramingFaultTooLong="The framing fault size ({0}) exceeds the quota.";
	public const string FramingContentTypeTooLong="The framing content type size ({0}) exceeds the quota.";
	public const string FramingValueNotAvailable="The value cannot be accessed because it has not yet been fully decoded.";
	public const string FramingAtEnd="An attempt was made to decode a value after the framing stream was ended.";
	public const string RemoteSecurityNotNegotiatedOnStreamUpgrade="Stream Security is required at {0}, but no security context was negotiated. This is likely caused by the remote endpoint missing a StreamSecurityBindingElement from its binding.";
	public const string BinaryEncoderSessionTooLarge="The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.";
	public const string BinaryEncoderSessionInvalid="The binary encoder session is not valid. There was an error decoding a previous message.";
	public const string BinaryEncoderSessionMalformed="The binary encoder session information is not properly formed.";
	public const string ReceiveShutdownReturnedFault="The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'";
	public const string ReceiveShutdownReturnedLargeFault="The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.";
	public const string ReceiveShutdownReturnedMessage="The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.";
	public const string MaxReceivedMessageSizeExceeded="The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.";
	public const string MaxSentMessageSizeExceeded="The maximum message size quota for outgoing messages ({0}) has been exceeded.";
	public const string FramingMaxMessageSizeExceeded="The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.";
	public const string StreamDoesNotSupportTimeout="TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.";
	public const string FilterExists="The filter already exists in the filter table.";
	public const string FilterUnexpectedError="An internal error has occurred. Unexpected error modifying filter table.";
	public const string FilterNodeQuotaExceeded="The number of XML infoset nodes inspected by the navigator has exceeded the quota ({0}).";
	public const string FilterCapacityNegative="Value cannot be negative.";
	public const string ActionFilterEmptyList="The set of actions cannot be empty.";
	public const string FilterUndefinedPrefix="The prefix '{0}' is not defined.";
	public const string FilterMultipleMatches="Multiple filters matched.";
	public const string FilterTableTypeMismatch="The type of IMessageFilterTable created for a particular Filter type must always be the same.";
	public const string FilterTableInvalidForLookup="The MessageFilterTable state is corrupt. The requested lookup cannot be performed.";
	public const string FilterBadTableType="The IMessageFilterTable created for a Filter cannot be a MessageFilterTable or a subclass of MessageFilterTable.";
	public const string FilterQuotaRange="NodeQuota must be greater than 0.";
	public const string FilterEmptyString="Parameter value cannot be an empty string.";
	public const string FilterInvalidInner="Required inner element '{0}' was not found.";
	public const string FilterInvalidAttribute="Invalid attribute on the XPath.";
	public const string FilterInvalidDialect="When present, the dialect attribute must have the value '{0}'.";
	public const string FilterCouldNotCompile="Could not compile the XPath expression '{0}' with the given XsltContext.";
	public const string FilterReaderNotStartElem="XmlReader not positioned at a start element.";
	public const string SeekableMessageNavInvalidPosition="The position is not valid for this navigator.";
	public const string SeekableMessageNavNonAtomized="Cannot call '{0}' on a non-atomized navigator.";
	public const string SeekableMessageNavIDNotSupported="XML unique ID not supported.";
	public const string SeekableMessageNavBodyForbidden="A filter has attempted to access the body of a Message. Use a MessageBuffer instead if body filtering is required.";
	public const string SeekableMessageNavOverrideForbidden="Not allowed to override prefix '{0}'.";
	public const string QueryNotImplemented="The function '{0}' is not implemented.";
	public const string QueryNotSortable="XPathNavigator positions cannot be compared.";
	public const string QueryMustBeSeekable="XPathNavigator must be a SeekableXPathNavigator.";
	public const string QueryContextNotSupportedInSequences="Context node is not supported in node sequences.";
	public const string QueryFunctionTypeNotSupported="IXsltContextFunction return type '{0}' not supported.";
	public const string QueryVariableTypeNotSupported="IXsltContextVariable type '{0}' not supported.";
	public const string QueryVariableNull="IXsltContextVariables cannot return null.";
	public const string QueryFunctionStringArg="The argument to an IXsltContextFunction could not be converted to a string.";
	public const string QueryItemAlreadyExists="An internal error has occurred. Item already exists.";
	public const string QueryBeforeNodes="Positioned before first element.";
	public const string QueryAfterNodes="Positioned after last element.";
	public const string QueryIteratorOutOfScope="The XPathNodeIterator has been invalidated. XPathNodeIterators passed as arguments to IXsltContextFunctions are only valid within the function. They cannot be cached for later use or returned as the result of the function.";
	public const string QueryCantGetStringForMovedIterator="The string value can't be determined because the XPathNodeIterator has been moved past the first node.";
	public const string AddressingVersionNotSupported="Addressing Version '{0}' is not supported.";
	public const string SupportedAddressingModeNotSupported="The '{0}' addressing mode is not supported.";
	public const string MessagePropertyReturnedNullCopy="The IMessageProperty could not be copied. CreateCopy returned null.";
	public const string MessageVersionUnknown="Unrecognized message version.";
	public const string EnvelopeVersionUnknown="Unrecognized envelope version: {0}.";
	public const string EnvelopeVersionNotSupported="Envelope Version '{0}' is not supported.";
	public const string CannotDetectAddressingVersion="Cannot detect WS-Addressing version. EndpointReference does not start with an Element.";
	public const string HeadersCannotBeAddedToEnvelopeVersion="Envelope Version '{0}' does not support adding Message Headers.";
	public const string AddressingHeadersCannotBeAddedToAddressingVersion="Addressing Version '{0}' does not support adding WS-Addressing headers.";
	public const string AddressingExtensionInBadNS="The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.";
	public const string MessageHeaderVersionNotSupported="The '{0}' header cannot be added because it does not support the specified message version '{1}'.";
	public const string MessageHasBeenCopied="This message cannot support the operation because it has been copied.";
	public const string MessageHasBeenWritten="This message cannot support the operation because it has been written.";
	public const string MessageHasBeenRead="This message cannot support the operation because it has been read.";
	public const string InvalidMessageState="An internal error has occurred. Invalid MessageState.";
	public const string MessageBodyReaderInvalidReadState="The body reader is in ReadState '{0}' and cannot be consumed.";
	public const string XmlBufferQuotaExceeded="The size necessary to buffer the XML content exceeded the buffer quota.";
	public const string XmlBufferInInvalidState="An internal error has occurred. The XML buffer is not in the correct state to perform the operation.";
	public const string MessageBodyMissing="A body element was not found inside the message envelope.";
	public const string MessageHeaderVersionMismatch="The version of the header(s) ({0}) differs from the version of the message ({1}).";
	public const string ManualAddressingRequiresAddressedMessages="Manual addressing is enabled on this factory, so all messages sent must be pre-addressed.";
	public const string OneWayHeaderNotFound="A one-way header was expected on this message and none was found. It is possible that your bindings are mismatched.";
	public const string ReceiveTimedOut="Receive on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string ReceiveTimedOut2="Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string WaitForMessageTimedOut="WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string ReceiveTimedOutNoLocalAddress="Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string ReceiveRequestTimedOutNoLocalAddress="Receive request timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string ReceiveRequestTimedOut="Receive request on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string SendToViaTimedOut="Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string CloseTimedOut="Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string OpenTimedOutEstablishingTransportSession="Open timed out after {0} while establishing a transport session to {1}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string RequestTimedOutEstablishingTransportSession="Request timed out after {0} while establishing a transport connection to {1}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string TcpConnectingToViaTimedOut="Connecting to via {0} timed out after {1}. Connection attempts were made to {2} of {3} available addresses ({4}). Check the RemoteAddress of your channel and verify that the DNS records for this endpoint correspond to valid IP Addresses. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string RequestChannelSendTimedOut="The request channel timed out attempting to send after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string RequestChannelWaitForReplyTimedOut="The request channel timed out while waiting for a reply after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string HttpTransportCannotHaveMultipleAuthenticationSchemes="The policy being imported for contract '{0}:{1}' contains multiple HTTP authentication scheme assertions.  Since at most one such assertion is allowed, policy import has failed.  This may be resolved by updating the policy to contain no more than one HTTP authentication scheme assertion.";
	public const string MultipleCCbesInParameters="More than one '{0}' objects were found in the BindingParameters of the BindingContext.  This is usually caused by having multiple '{0}' objects in a CustomBinding. Remove all but one of these elements.";
	public const string CookieContainerBindingElementNeedsHttp="The '{0}' can only be used with HTTP (or HTTPS) transport.";
	public const string HttpIfModifiedSinceParseError="The value specified, '{0}', for the If-Modified-Since header does not parse into a valid date. Check the property value and ensure that it is of the proper format.";
	public const string HttpSoapActionMismatch="The SOAP action specified on the message, '{0}', does not match the action specified on the HttpRequestMessageProperty, '{1}'.";
	public const string HttpSoapActionMismatchContentType="The SOAP action specified on the message, '{0}', does not match the action specified in the content-type of the HttpRequestMessageProperty, '{1}'.";
	public const string HttpSoapActionMismatchFault="The SOAP action specified on the message, '{0}', does not match the HTTP SOAP Action, '{1}'. ";
	public const string HttpContentTypeFormatException="An error ({0}) occurred while parsing the content type of the HTTP request. The content type was: {1}.";
	public const string HttpServerTooBusy="The HTTP service located at {0} is unavailable.  This could be because the service is too busy or because no endpoint was found listening at the specified address. Please ensure that the address is correct and try accessing the service again later.";
	public const string HttpRequestAborted="The HTTP request to '{0}' was aborted.  This may be due to the local channel being closed while the request was still in progress.  If this behavior is not desired, then update your code so that it does not close the channel while request operations are still in progress.";
	public const string HttpRequestTimedOut="The HTTP request to '{0}' has exceeded the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string HttpResponseTimedOut="The HTTP request to '{0}' has exceeded the allotted timeout of {1} while reading the response. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string HttpTransferError="An error ({0}) occurred while transmitting data over the HTTP channel.";
	public const string HttpReceiveFailure="An error occurred while receiving the HTTP response to {0}. This could be due to the service endpoint binding not using the HTTP protocol. This could also be due to an HTTP request context being aborted by the server (possibly due to the service shutting down). See server logs for more details.";
	public const string HttpSendFailure="An error occurred while making the HTTP request to {0}. This could be due to the fact that the server certificate is not configured properly with HTTP.SYS in the HTTPS case. This could also be caused by a mismatch of the security binding between the client and the server.";
	public const string HttpAuthDoesNotSupportRequestStreaming="HTTP request streaming cannot be used in conjunction with HTTP authentication.  Either disable request streaming or specify anonymous HTTP authentication.";
	public const string ReplyAlreadySent="A reply has already been sent from this RequestContext.";
	public const string HttpInvalidListenURI="Unable to start the HTTP listener. The URI provided, '{0}', is invalid for listening. Check the base address of your service and verify that it is a valid URI.";
	public const string RequestContextAborted="The requestContext has been aborted.";
	public const string ReceiveContextCannotBeUsed="The receive context, {0}, is in the {1} state.  Receive contexts cannot be used for sending delayed acks unless they are in the Received state.";
	public const string ReceiveContextInInvalidState="The receive context, {0}, is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that receive context.";
	public const string ReceiveContextFaulted="The receive context, {0}, cannot be used for sending delayed acks because it is in the Faulted state.";
	public const string UnrecognizedHostNameComparisonMode="Invalid HostNameComparisonMode value: {0}.";
	public const string BadData="Invalid data buffer.";
	public const string InvalidRenewResponseAction="A security session renew response was received with an invalid action '{0}'.";
	public const string InvalidCloseResponseAction="A security session close response was received with an invalid action '{0}',";
	public const string IncompatibleBehaviors="TransactedBatchingBehavior cannot be used when ReceiveContext is being used.";
	public const string NullSessionRequestMessage="Could not formulate request message for security session operation '{0}'.";
	public const string IssueSessionTokenHandlerNotSet="There is no handler registered for session token issuance event.";
	public const string RenewSessionTokenHandlerNotSet="There is no handler registered for session token renew event.";
	public const string WrongIdentityRenewingToken="The identity of the security session renew message does not match the identity of the session token.";
	public const string InvalidRstRequestType="The RequestSecurityToken has an invalid or unspecified RequestType '{0}'.";
	public const string NoCloseTargetSpecified="The RequestSecurityToken must specify a CloseTarget.";
	public const string FailedSspiNegotiation="Secure channel cannot be opened because security negotiation with the remote endpoint has failed. This may be due to absent or incorrectly specified EndpointIdentity in the EndpointAddress used to create the channel. Please verify the EndpointIdentity specified or implied by the EndpointAddress correctly identifies the remote endpoint. ";
	public const string BadCloseTarget="The CloseTarget specified '{0}' does not identify the security token that signed the message.";
	public const string RenewSessionMissingSupportingToken="The renew security session message does not have the session token as a supporting token.";
	public const string NoRenewTargetSpecified="The RequestSecurityToken must specify a RenewTarget.";
	public const string BadRenewTarget="There is no endorsing session token that matches the specified RenewTarget '{0}'.";
	public const string BadEncryptedBody="Invalid format for encrypted body.";
	public const string BadEncryptionState="The EncryptedData or EncryptedKey is in an invalid state for this operation.";
	public const string NoSignaturePartsSpecified="No signature message parts were specified for messages with the '{0}' action.";
	public const string NoEncryptionPartsSpecified="No encryption message parts were specified for messages with the '{0}' action.";
	public const string SecuritySessionFaultReplyWasSent="The receiver sent back a security session fault message. Retry the request.";
	public const string InnerListenerFactoryNotSet="The Inner listener factory of {0} must be set before this operation.";
	public const string SecureConversationBootstrapCannotUseSecureConversation="Cannot create security binding element based on configuration data. The secure conversation bootstrap requires another secure conversation which is not supported. ";
	public const string InnerChannelFactoryWasNotSet="Cannot open ChannelFactory as the inner channel factory was not set during the initialization process.";
	public const string SecurityProtocolFactoryDoesNotSupportDuplex="Duplex security is not supported by the security protocol factory '{0}'.";
	public const string SecurityProtocolFactoryDoesNotSupportRequestReply="Request-reply security is not supported by the security protocol factory '{0}'.";
	public const string SecurityProtocolFactoryShouldBeSetBeforeThisOperation="The security protocol factory must be set before this operation is performed.";
	public const string SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation="Security session protocol factory must be set before this operation is performed.";
	public const string SecureConversationSecurityTokenParametersRequireBootstrapBinding="Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.";
	public const string PropertySettingErrorOnProtocolFactory="The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.";
	public const string ProtocolFactoryCouldNotCreateProtocol="The protocol factory cannot create a protocol.";
	public const string IdentityCheckFailedForOutgoingMessage="The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.";
	public const string IdentityCheckFailedForIncomingMessage="The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.";
	public const string DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim="The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.";
	public const string DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim="The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.";
	public const string DnsIdentityCheckFailedForIncomingMessage="Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. ";
	public const string DnsIdentityCheckFailedForOutgoingMessage="Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. ";
	public const string SerializedTokenVersionUnsupported="The serialized token version {0} is unsupported.";
	public const string AuthenticatorNotPresentInRSTRCollection="The RequestSecurityTokenResponseCollection does not contain an authenticator.";
	public const string RSTRAuthenticatorHasBadContext="The negotiation RequestSecurityTokenResponse has a different context from the authenticator RequestSecurityTokenResponse.";
	public const string ServerCertificateNotProvided="The recipient did not provide its certificate.  This certificate is required by the TLS protocol.  Both parties must have access to their certificates.";
	public const string RSTRAuthenticatorNotPresent="The authenticator was not included in the final leg of negotiation.";
	public const string RSTRAuthenticatorIncorrect="The RequestSecurityTokenResponse CombinedHash is incorrect.";
	public const string ClientCertificateNotProvided="The certificate for the client has not been provided.  The certificate can be set on the ClientCredentials or ServiceCredentials.";
	public const string ClientCertificateNotProvidedOnServiceCredentials="The client certificate is not provided. Specify a client certificate in ServiceCredentials. ";
	public const string ClientCertificateNotProvidedOnClientCredentials="The client certificate is not provided. Specify a client certificate in ClientCredentials. ";
	public const string ServiceCertificateNotProvidedOnServiceCredentials="The service certificate is not provided. Specify a service certificate in ServiceCredentials. ";
	public const string ServiceCertificateNotProvidedOnClientCredentials="The service certificate is not provided for target '{0}'. Specify a service certificate in ClientCredentials. ";
	public const string UserNamePasswordNotProvidedOnClientCredentials="The username is not provided. Specify username in ClientCredentials.";
	public const string ObjectIsReadOnly="Object is read-only.";
	public const string EmptyXmlElementError="Element {0} cannot be empty.";
	public const string UnexpectedXmlChildNode="XML child node {0} of type {1} is unexpected for element {2}.";
	public const string ContextAlreadyRegistered="The context-id={0} (generation-id={1}) is already registered with SecurityContextSecurityTokenAuthenticator.";
	public const string ContextAlreadyRegisteredNoKeyGeneration="The context-id={0} (no key generation-id) is already registered with SecurityContextSecurityTokenAuthenticator.";
	public const string ContextNotPresent="There is no SecurityContextSecurityToken with context-id={0} (generation-id={1}) registered with SecurityContextSecurityTokenAuthenticator.";
	public const string ContextNotPresentNoKeyGeneration="There is no SecurityContextSecurityToken with context-id={0} (no key generation-id) registered with SecurityContextSecurityTokenAuthenticator.";
	public const string InvalidSecurityContextCookie="The SecurityContextSecurityToken has an invalid Cookie. The following error occurred when processing the Cookie: '{0}'.";
	public const string SecurityContextNotRegistered="The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.";
	public const string SecurityContextExpired="The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) has expired.";
	public const string SecurityContextExpiredNoKeyGeneration="The SecurityContextSecurityToken with context-id={0} (no key generation-id) has expired.";
	public const string NoSecurityContextIdentifier="The SecurityContextSecurityToken does not have a context-id.";
	public const string MessageMustHaveViaOrToSetForSendingOnServerSideCompositeDuplexChannels="For sending a message on server side composite duplex channels, the message must have either the 'Via' property or the 'To' header set.";
	public const string MessageViaCannotBeAddressedToAnonymousOnServerSideCompositeDuplexChannels="The 'Via' property on the message is set to Anonymous Uri '{0}'. Please set the 'Via' property to a non-anonymous address as message cannot be addressed to anonymous Uri on server side composite duplex channels.";
	public const string MessageToCannotBeAddressedToAnonymousOnServerSideCompositeDuplexChannels="The 'To' header on the message is set to Anonymous Uri '{0}'. Please set the 'To' header to a non-anonymous address as message cannot be addressed to anonymous Uri on server side composite duplex channels.";
	public const string SecurityBindingNotSetUpToProcessOutgoingMessages="This SecurityProtocol instance was not set up to process outgoing messages.";
	public const string SecurityBindingNotSetUpToProcessIncomingMessages="This SecurityProtocol instance was not set up to process incoming messages.";
	public const string TokenProviderCannotGetTokensForTarget="The token provider cannot get tokens for target '{0}'.";
	public const string UnsupportedKeyDerivationAlgorithm="Key derivation algorithm '{0}' is not supported.";
	public const string CannotFindCorrelationStateForApplyingSecurity="Cannot find the correlation state for applying security to reply at the responder.";
	public const string ReplyWasNotSignedWithRequiredSigningToken="The reply was not signed with the required signing token.";
	public const string EncryptionNotExpected="Encryption not expected for this message.";
	public const string SignatureNotExpected="A signature is not expected for this message.";
	public const string InvalidQName="The QName is invalid.";
	public const string UnknownICryptoType="The ICrypto implementation '{0}' is not supported.";
	public const string SameProtocolFactoryCannotBeSetForBothDuplexDirections="On DuplexSecurityProtocolFactory, the same protocol factory cannot be set for the forward and reverse directions.";
	public const string SuiteDoesNotAcceptAlgorithm="The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.";
	public const string TokenDoesNotSupportKeyIdentifierClauseCreation="'{0}' does not support '{1}' creation.";
	public const string UnableToCreateICryptoFromTokenForSignatureVerification="Cannot create an ICrypto interface from the '{0}' token for signature verification.";
	public const string MessageSecurityVerificationFailed="Message security verification failed.";
	public const string TransportSecurityRequireToHeader="Transport secured messages should have the 'To' header specified.";
	public const string TransportSecuredMessageMissingToHeader="The message received over Transport security was missing the 'To' header.";
	public const string UnsignedToHeaderInTransportSecuredMessage="The message received over Transport security has unsigned 'To' header.";
	public const string TransportSecuredMessageHasMoreThanOneToHeader="More than one 'To' header specified in a message secured by Transport Security.";
	public const string TokenNotExpectedInSecurityHeader="Received security header contains unexpected token '{0}'.";
	public const string CannotFindCert="Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.";
	public const string CannotFindCertForTarget="Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.";
	public const string FoundMultipleCerts="Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.";
	public const string FoundMultipleCertsForTarget="Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.";
	public const string MissingKeyInfoInEncryptedKey="The KeyInfo clause is missing or empty in EncryptedKey.";
	public const string EncryptedKeyWasNotEncryptedWithTheRequiredEncryptingToken="The EncryptedKey clause was not wrapped with the required encryption token '{0}'.";
	public const string MessageWasNotEncryptedWithTheRequiredEncryptingToken="The message was not encrypted with the required encryption token.";
	public const string TimestampMustOccurFirstInSecurityHeaderLayout="The timestamp must occur first in this security header layout.";
	public const string TimestampMustOccurLastInSecurityHeaderLayout="The timestamp must occur last in this security header layout.";
	public const string AtMostOnePrimarySignatureInReceiveSecurityHeader="Only one primary signature is allowed in a security header.";
	public const string SigningTokenHasNoKeys="The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).";
	public const string SigningTokenHasNoKeysSupportingTheAlgorithmSuite="The signing token {0} has no key that supports the algorithm suite {1}.";
	public const string DelayedSecurityApplicationAlreadyCompleted="Delayed security application has already been completed.";
	public const string UnableToResolveKeyInfoClauseInDerivedKeyToken="Cannot resolve KeyInfo in derived key token for resolving source token: KeyInfoClause '{0}'.";
	public const string UnableToDeriveKeyFromKeyInfoClause="KeyInfo clause '{0}' resolved to token '{1}', which does not contain a Symmetric key that can be used for derivation.";
	public const string UnableToResolveKeyInfoForVerifyingSignature="Cannot resolve KeyInfo for verifying signature: KeyInfo '{0}', available tokens '{1}'.";
	public const string UnableToResolveKeyInfoForUnwrappingToken="Cannot resolve KeyInfo for unwrapping key: KeyInfo '{0}', available tokens '{1}'.";
	public const string UnableToResolveKeyInfoForDecryption="Cannot resolve KeyInfo for decryption: KeyInfo '{0}', available tokens '{1}'.";
	public const string EmptyBase64Attribute="An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.";
	public const string RequiredSecurityHeaderElementNotSigned="The security header element '{0}' with the '{1}' id must be signed.";
	public const string RequiredSecurityTokenNotSigned="The '{0}' security token with the '{1}' attachment mode must be signed.";
	public const string RequiredSecurityTokenNotEncrypted="The '{0}' security token with the '{1}' attachment mode must be encrypted.";
	public const string MessageBodyOperationNotValidInBodyState="Operation '{0}' is not valid in message body state '{1}'.";
	public const string EncryptedKeyWithReferenceListNotAllowed="EncryptedKey with ReferenceList is not allowed according to the current settings.";
	public const string UnableToFindTokenAuthenticator="Cannot find a token authenticator for the '{0}' token type. Tokens of that type cannot be accepted according to current security settings.";
	public const string NoPartsOfMessageMatchedPartsToSign="No signature was created because not part of the message matched the supplied message part specification.";
	public const string BasicTokenCannotBeWrittenWithoutEncryption="Supporting SecurityToken cannot be written without encryption.";
	public const string DuplicateIdInMessageToBeVerified="The '{0}' id occurred twice in the message that is supplied for verification.";
	public const string UnsupportedCanonicalizationAlgorithm="Canonicalization algorithm '{0}' is not supported.";
	public const string NoKeyInfoInEncryptedItemToFindDecryptingToken="The KeyInfo value was not found in the encrypted item to find the decrypting token.";
	public const string NoKeyInfoInSignatureToFindVerificationToken="No KeyInfo in signature to find verification token.";
	public const string SecurityHeaderIsEmpty="Security header is empty.";
	public const string EncryptionMethodMissingInEncryptedData="The encryption method is missing in encrypted data.";
	public const string EncryptedHeaderAttributeMismatch="The Encrypted Header and the Security Header '{0}' attribute did not match. Encrypted Header: {1}. Security Header: {2}.";
	public const string AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck="At most one reference list is supported with default policy check.";
	public const string AtMostOneSignatureIsSupportedWithDefaultPolicyCheck="At most one signature is supported with default policy check.";
	public const string UnexpectedEncryptedElementInSecurityHeader="Unexpected encrypted element in security header.";
	public const string MissingIdInEncryptedElement="Id is missing in encrypted item in security header.";
	public const string TokenManagerCannotCreateTokenReference="The supplied token manager cannot create a token reference.";
	public const string TimestampToSignHasNoId="The timestamp element added to security header to sign has no id.";
	public const string EncryptedHeaderXmlMustHaveId="An encrypted header must have an id.";
	public const string UnableToResolveDataReference="The data reference '{0}' could not be resolved in the received message.";
	public const string TimestampAlreadySetForSecurityHeader="A timestamp element has already been set for this security header.";
	public const string DuplicateTimestampInSecurityHeader="More than one Timestamp element was present in security header.";
	public const string MismatchInSecurityOperationToken="The incoming message was signed with a token which was different from what used to encrypt the body.  This was not expected.";
	public const string UnableToCreateSymmetricAlgorithmFromToken="Cannot create the '{0}' symmetric algorithm from the token.";
	public const string UnknownEncodingInBinarySecurityToken="Unrecognized encoding occurred while reading the binary security token.";
	public const string UnableToResolveReferenceUriForSignature="Cannot resolve reference URI '{0}' in signature to compute digest.";
	public const string NoTimestampAvailableInSecurityHeaderToDoReplayDetection="No timestamp is available in the security header to do replay detection.";
	public const string NoSignatureAvailableInSecurityHeaderToDoReplayDetection="No signature is available in the security header to provide the nonce for replay detection.";
	public const string CouldNotFindNamespaceForPrefix="There is no namespace binding for prefix '{0}' in scope.";
	public const string DerivedKeyCannotDeriveFromSecret="Derived Key Token cannot derive key from the secret.";
	public const string DerivedKeyPosAndGenBothSpecified="Both offset and generation cannot be specified for Derived Key Token.";
	public const string DerivedKeyPosAndGenNotSpecified="Either offset or generation must be specified for Derived Key Token.";
	public const string DerivedKeyTokenRequiresTokenReference="DerivedKeyToken requires a reference to a token.";
	public const string DerivedKeyLengthTooLong="DerivedKey length ({0}) exceeds the allowed settings ({1}).";
	public const string DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong="The Implicit derived key clause '{0}' specifies a derivation key length ({1}) which exceeds the allowed maximum length ({2}).";
	public const string DerivedKeyInvalidOffsetSpecified="The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.";
	public const string DerivedKeyInvalidGenerationSpecified="The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.";
	public const string ChildNodeTypeMissing="The XML element {0} does not have a child of type {1}.";
	public const string NoLicenseXml="RequestedSecurityToken not specified in RequestSecurityTokenResponse.";
	public const string UnsupportedBinaryEncoding="Binary encoding {0} is not supported.";
	public const string BadKeyEncryptionAlgorithm="Invalid key encryption algorithm {0}.";
	public const string SPS_InvalidAsyncResult="The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.";
	public const string UnableToCreateTokenReference="Unable to create token reference.";
	public const string NonceLengthTooShort="The specified nonce is too short. The minimum required nonce length is 4 bytes.";
	public const string NoBinaryNegoToSend="There is no binary negotiation to send to the other party.";
	public const string BadSecurityNegotiationContext="Security negotiation failure because an incorrect Context attribute specified in RequestSecurityToken/RequestSecurityTokenResponse from the other party.";
	public const string NoBinaryNegoToReceive="No binary negotiation was received from the other party.";
	public const string ProofTokenWasNotWrappedCorrectly="The proof token was not wrapped correctly in the RequestSecurityTokenResponse.";
	public const string NoServiceTokenReceived="Final RSTR from other party does not contain a service token.";
	public const string InvalidSspiNegotiation="The Security Support Provider Interface (SSPI) negotiation failed.";
	public const string CannotAuthenticateServer="Cannot authenticate the other party.";
	public const string IncorrectBinaryNegotiationValueType="Incoming binary negotiation has invalid ValueType {0}.";
	public const string ChannelNotOpen="The channel is not open.";
	public const string FailToRecieveReplyFromNegotiation="Security negotiation failed because the remote party did not send back a reply in a timely manner. This may be because the underlying transport connection was aborted.";
	public const string MessageSecurityVersionOutOfRange="SecurityVersion must be WsSecurity10 or WsSecurity11.";
	public const string CreationTimeUtcIsAfterExpiryTime="Creation time must be before expiration time.";
	public const string NegotiationStateAlreadyPresent="Negotiation state already exists for context '{0}'.";
	public const string CannotFindNegotiationState="Cannot find the negotiation state for the context '{0}'.";
	public const string OutputNotExpected="Send cannot be called when the session does not expect output.";
	public const string SessionClosedBeforeDone="The session was closed before message transfer was complete.";
	public const string CacheQuotaReached="The item cannot be added. The maximum cache size is ({0} items).";
	public const string NoServerX509TokenProvider="The server's X509SecurityTokenProvider cannot be null.";
	public const string UnexpectedBinarySecretType="Expected binary secret of type {0} but got secret of type {1}.";
	public const string UnsupportedPasswordType="The '{0}' username token has an unsupported password type.";
	public const string UnrecognizedIdentityPropertyType="Unrecognized identity property type: '{0}'.";
	public const string UnableToDemuxChannel="There was no channel that could accept the message with action '{0}'.";
	public const string EndpointNotFound="There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details.";
	public const string MaxReceivedMessageSizeMustBeInIntegerRange="This factory buffers messages, so the message sizes must be in the range of an integer value.";
	public const string MaxBufferSizeMustMatchMaxReceivedMessageSize="For TransferMode.Buffered, MaxReceivedMessageSize and MaxBufferSize must be the same value.";
	public const string MaxBufferSizeMustNotExceedMaxReceivedMessageSize="MaxBufferSize must not exceed MaxReceivedMessageSize.";
	public const string MessageSizeMustBeInIntegerRange="This Factory buffers messages, so the message sizes must be in the range of a int value.";
	public const string UriLengthExceedsMaxSupportedSize="URI {0} could not be set because its size ({1}) exceeds the max supported size ({2}).";
	public const string InValidateIdPrefix="Expecting first char - c - to be in set [Char.IsLetter(c) && c == '_', found '{0}'.";
	public const string InValidateId="Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.";
	public const string HttpRegistrationAlreadyExists="HTTP could not register URL {0}. Another application has already registered this URL with HTTP.SYS.";
	public const string HttpRegistrationAccessDenied="HTTP could not register URL {0}. Your process does not have access rights to this namespace (see http://go.microsoft.com/fwlink/?LinkId=70353 for details).";
	public const string HttpRegistrationPortInUse="HTTP could not register URL {0} because TCP port {1} is being used by another application.";
	public const string HttpRegistrationLimitExceeded="HTTP could not register URL {0} because the MaxEndpoints quota has been exceeded. To correct this, either close other HTTP-based services, or increase your MaxEndpoints registry key setting (see http://go.microsoft.com/fwlink/?LinkId=70352 for details).";
	public const string UnexpectedHttpResponseCode="The remote server returned an unexpected response: ({0}) {1}.";
	public const string HttpContentLengthIncorrect="The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.";
	public const string OneWayUnexpectedResponse="A response was received from a one-way send over the underlying IRequestChannel. Make sure the remote endpoint has a compatible binding at its endpoint (one that contains OneWayBindingElement).";
	public const string MissingContentType="The receiver returned an error indicating that the content type was missing on the request to {0}.  See the inner exception for more information.";
	public const string DuplexChannelAbortedDuringOpen="Duplex channel to {0} was aborted during the open process.";
	public const string OperationAbortedDuringConnectionEstablishment="Operation was aborted while establishing a connection to {0}.";
	public const string HttpAddressingNoneHeaderOnWire="The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.  If this is not desired, then update your HTTP binding to support a different AddressingVersion.";
	public const string MessageXmlProtocolError="There is a problem with the XML that was received from the network. See inner exception for more details.";
	public const string TcpV4AddressInvalid="An IPv4 address was specified ({0}), but IPv4 is not enabled on this machine. ";
	public const string TcpV6AddressInvalid="An IPv6 address was specified ({0}), but IPv6 is not enabled on this machine. ";
	public const string UniquePortNotAvailable="Cannot find a unique port number that is available for both IPv4 and IPv6.";
	public const string TcpAddressInUse="There is already a listener on IP endpoint {0}. This could happen if there is another application already listening on this endpoint or if you have multiple service endpoints in your service host with the same IP endpoint but with incompatible binding configurations.";
	public const string TcpConnectNoBufs="Insufficient winsock resources available to complete socket connection initiation.";
	public const string InsufficentMemory="Insufficient memory avaliable to complete the operation.";
	public const string TcpConnectError="Could not connect to {0}. TCP error code {1}: {2}. ";
	public const string TcpConnectErrorWithTimeSpan="Could not connect to {0}. The connection attempt lasted for a time span of {3}. TCP error code {1}: {2}. ";
	public const string TcpListenError="A TCP error ({0}: {1}) occurred while listening on IP Endpoint={2}.";
	public const string TcpTransferError="A TCP error ({0}: {1}) occurred while transmitting data.";
	public const string TcpTransferErrorWithIP="A TCP error ({0}: {1}) occurred while transmitting data. The local IP address and port is {2}. The remote IP address and port is {3}.";
	public const string TcpLocalConnectionAborted="The socket connection was aborted by your local machine. This could be caused by a channel Abort(), or a transmission error from another thread using this socket.";
	public const string HttpResponseAborted="The HTTP request context was aborted while writing the response.  As a result, the response may not have been completely written to the network.  This can be remedied by gracefully closing the request context rather than aborting it.";
	public const string TcpConnectionResetError="The socket connection was aborted. This could be caused by an error processing your message or a receive timeout being exceeded by the remote host, or an underlying network resource issue. Local socket timeout was '{0}'.";
	public const string TcpConnectionResetErrorWithIP="The socket connection was aborted. This could be caused by an error processing your message or a receive timeout being exceeded by the remote host, or an underlying network resource issue. Local socket timeout was '{0}'. The local IP address and port is {1}. The remote IP address and port is {2}.";
	public const string TcpConnectionTimedOut="The socket transfer timed out after {0}. You have exceeded the timeout set on your binding. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string TcpConnectionTimedOutWithIP="The socket transfer timed out after {0}. You have exceeded the timeout set on your binding. The time allotted to this operation may have been a portion of a longer timeout. The local IP address and port is {1}. The remote IP address and port is {2}.";
	public const string SocketConnectionDisposed="The socket connection has been disposed.";
	public const string SocketListenerDisposed="The socket listener has been disposed.";
	public const string SocketListenerNotListening="The socket listener is not listening.";
	public const string DuplexSessionListenerNotFound="No duplex session listener was listening at {0}. This could be due to an incorrect via set on the client or a binding mismatch.";
	public const string HttpTargetNameDictionaryConflict="The entry found in AuthenticationManager's CustomTargetNameDictionary for {0} does not match the requested identity of {1}.";
	public const string HttpContentTypeHeaderRequired="An HTTP Content-Type header is required for SOAP messaging and none was found.";
	public const string ContentTypeMismatch="Content Type {0} was sent to a service expecting {1}.  The client and service bindings may be mismatched.";
	public const string ResponseContentTypeMismatch="The content type {0} of the response message does not match the content type of the binding ({1}). If using a custom encoder, be sure that the IsContentTypeSupported method is implemented properly. The first {2} bytes of the response were: '{3}'.";
	public const string ResponseContentTypeNotSupported="The content type {0} of the message is not supported by the encoder.";
	public const string HttpToMustEqualVia="The binding specified requires that the to and via URIs must match because the Addressing Version is set to None. The to URI specified was '{0}'. The via URI specified was '{1}'.";
	public const string NullReferenceOnHttpResponse="The server challenged this request and streamed requests cannot be resubmitted. To enable HTTP server challenges, set your TransferMode to Buffered or StreamedResponse.";
	public const string FramingContentTypeMismatch="Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.";
	public const string FramingFaultUnrecognized="Server faulted with code '{0}'.";
	public const string FramingContentTypeTooLongFault="Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.";
	public const string FramingViaTooLongFault="Via '{0}' is too long to be processed by the remote host. See the server logs for more details.";
	public const string FramingModeNotSupportedFault="The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.";
	public const string FramingVersionNotSupportedFault="The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.";
	public const string FramingUpgradeInvalid="The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).";
	public const string SecurityServerTooBusy="Server '{0}' sent back a fault indicating it is too busy to process the request. Please retry later. Please see the inner exception for fault details.";
	public const string SecurityEndpointNotFound="Server '{0}' sent back a fault indicating it is in the process of shutting down. Please see the inner exception for fault details.";
	public const string ServerTooBusy="Server '{0}' is too busy to process this request. Try again later.";
	public const string UpgradeProtocolNotSupported="Protocol Type {0} was sent to a service that does not support that type of upgrade.";
	public const string UpgradeRequestToNonupgradableService=".Net Framing upgrade request for {0} was sent to a service that is not setup to receive upgrades.";
	public const string PreambleAckIncorrect="You have tried to create a channel to a service that does not support .Net Framing. ";
	public const string PreambleAckIncorrectMaybeHttp="You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.";
	public const string StreamError="An error occurred while transmitting data.";
	public const string ServerRejectedUpgradeRequest="The server rejected the upgrade request.";
	public const string ServerRejectedSessionPreamble="The server at {0} rejected the session-establishment request.";
	public const string UnableToResolveHost="Cannot resolve the host name of URI \"{0}\" using DNS.";
	public const string HttpRequiresSingleAuthScheme="The '{0}' authentication scheme has been specified on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.";
	public const string HttpAuthSchemeCannotBeNone="The value specified for the AuthenticationScheme property on the HttpTransportBindingElement ('{0}') is not allowed when building a ChannelFactory. If you used a standard binding, ensure the ClientCredentialType is not set to HttpClientCredentialType.InheritedFromHost, a value which is invalid on a client. If you set the value to '{0}' directly on the HttpTransportBindingElement, please set it to Digest, Negotiate, NTLM, Basic, or Anonymous.";
	public const string HttpProxyRequiresSingleAuthScheme="The '{0}' authentication scheme has been specified for the proxy on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.";
	public const string HttpMutualAuthNotSatisfied="The remote HTTP server did not satisfy the mutual authentication requirement.";
	public const string HttpAuthorizationFailed="The HTTP request is unauthorized with client authentication scheme '{0}'. The authentication header received from the server was '{1}'.";
	public const string HttpAuthenticationFailed="The HTTP request with client authentication scheme '{0}' failed with '{1}' status.";
	public const string HttpAuthorizationForbidden="The HTTP request was forbidden with client authentication scheme '{0}'.";
	public const string InvalidUriScheme="The provided URI scheme '{0}' is invalid; expected '{1}'.";
	public const string HttpAuthSchemeAndClientCert="The HTTPS listener factory was configured to require a client certificate and the '{0}' authentication scheme. However, only one form of client authentication can be required at once.";
	public const string NoTransportManagerForUri="Could not find an appropriate transport manager for listen URI '{0}'.";
	public const string ListenerFactoryNotRegistered="The specified channel listener at '{0}' is not registered with this transport manager.";
	public const string HttpsExplicitIdentity="The HTTPS channel factory does not support explicit specification of an identity in the EndpointAddress unless the authentication scheme is NTLM or Negotiate.";
	public const string HttpsIdentityMultipleCerts="The endpoint identity specified when creating the HTTPS channel to '{0}' contains multiple server certificates.  However, the HTTPS transport only supports the specification of a single server certificate.  In order to create an HTTPS channel, please specify no more than one server certificate in the endpoint identity.";
	public const string HttpsServerCertThumbprintMismatch="The server certificate with name '{0}' failed identity verification because its thumbprint ('{1}') does not match the one specified in the endpoint identity ('{2}').  As a result, the current HTTPS request has failed.  Please update the endpoint identity used on the client or the certificate used by the server.";
	public const string DuplicateRegistration="A registration already exists for URI '{0}'.";
	public const string SecureChannelFailure="Could not establish secure channel for SSL/TLS with authority '{0}'.";
	public const string TrustFailure="Could not establish trust relationship for the SSL/TLS secure channel with authority '{0}'.";
	public const string NoCompatibleTransportManagerForUri="Could not find a compatible transport manager for URI '{0}'.";
	public const string HttpSpnNotFound="The SPN for the responding server at URI '{0}' could not be determined.";
	public const string StreamMutualAuthNotSatisfied="The remote server did not satisfy the mutual authentication requirement.";
	public const string TransferModeNotSupported="Transfer mode {0} is not supported by {1}.";
	public const string InvalidTokenProvided="The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.";
	public const string NoUserNameTokenProvided="The required UserNameSecurityToken was not provided.";
	public const string RemoteIdentityFailedVerification="The following remote identity failed verification: '{0}'.";
	public const string UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress="You cannot specify an explicit Proxy Address as well as UseDefaultWebProxy=true in your HTTP Transport Binding Element.";
	public const string ProxyImpersonationLevelMismatch="The HTTP proxy authentication credential specified an impersonation level restriction ({0}) that is stricter than the restriction for target server authentication ({1}).";
	public const string ProxyAuthenticationLevelMismatch="The HTTP proxy authentication credential specified an mutual authentication requirement ({0}) that is stricter than the requirement for target server authentication ({1}).";
	public const string CredentialDisallowsNtlm="The NTLM authentication scheme was specified, but the target credential does not allow NTLM.";
	public const string DigestExplicitCredsImpersonationLevel="The impersonation level '{0}' was specified, yet HTTP Digest authentication can only support 'Impersonation' level when used with an explicit credential.";
	public const string UriGeneratorSchemeMustNotBeEmpty="The scheme parameter must not be empty.";
	public const string UnsupportedSslProtectionLevel="The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.";
	public const string HttpNoTrackingService="{0}. This often indicates that a service that HTTP.SYS depends upon (such as httpfilter) is not started.";
	public const string HttpNetnameDeleted="{0}. This often indicates that the HTTP client has prematurely closed the underlying TCP connection.";
	public const string TimeoutServiceChannelConcurrentOpen1="Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string TimeoutServiceChannelConcurrentOpen2="Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string TimeSpanMustbeGreaterThanTimeSpanZero="TimeSpan must be greater than TimeSpan.Zero.";
	public const string TimeSpanCannotBeLessThanTimeSpanZero="TimeSpan cannot be less than TimeSpan.Zero.";
	public const string ValueMustBeNonNegative="The value of this argument must be non-negative.";
	public const string ValueMustBePositive="The value of this argument must be positive.";
	public const string ValueMustBeGreaterThanZero="The value of this argument must be greater than 0.";
	public const string ValueMustBeInRange="The value of this argument must fall within the range {0} to {1}.";
	public const string OffsetExceedsBufferBound="The specified offset exceeds the upper bound of the buffer ({0}).";
	public const string OffsetExceedsBufferSize="The specified offset exceeds the buffer size ({0} bytes).";
	public const string SizeExceedsRemainingBufferSpace="The specified size exceeds the remaining buffer space ({0} bytes).";
	public const string SpaceNeededExceedsMessageFrameOffset="The space needed for encoding ({0} bytes) exceeds the message frame offset.";
	public const string FaultConverterDidNotCreateFaultMessage="{0} returned true from OnTryCreateFaultMessage, but did not return a fault message.";
	public const string FaultConverterCreatedFaultMessage="{0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.";
	public const string FaultConverterDidNotCreateException="{0} returned true from OnTryCreateException, but did not return an Exception.";
	public const string FaultConverterCreatedException="{0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).";
	public const string InfoCardInvalidChain="Policy chain contains self issued URI or a managed issuer in the wrong position.";
	public const string FullTrustOnlyBindingElementSecurityCheck1="The Binding with name {0} failed validation because it contains a BindingElement with type {1} which is not supported in partial trust. Consider using BasicHttpBinding or WSHttpBinding, or hosting your application in a full-trust environment.";
	public const string FullTrustOnlyBindingElementSecurityCheckWSHttpBinding1="The WSHttpBinding with name {0} failed validation because it contains a BindingElement with type {1} which is not supported in partial trust. Consider disabling the message security and reliable session options, using BasicHttpBinding, or hosting your application in a full-trust environment.";
	public const string FullTrustOnlyBindingSecurityCheck1="The Binding with name {0} failed validation because the Binding type {1} is not supported in partial trust. Consider using BasicHttpBinding or WSHttpBinding, or hosting your application in a full-trust environment.";
	public const string PartialTrustServiceCtorNotVisible="The Service with name '{0}' could not be constructed because the application does not have permission to construct the type: both the Type and its default parameter-less constructor must be public.";
	public const string PartialTrustServiceMethodNotVisible="The Method with name '{1}' in Type '{0}' could not be invoked because the application does not have permission to invoke the method: both the Method and its containing Type must be public.";
	public const string PartialTrustPerformanceCountersNotEnabled="Access to performance counters is denied. Application may be running in partial trust. Either disable performance counters or configure the application to run in full trust.";
	public const string PartialTrustWMINotEnabled="Access to windows management instrumentation (WMI) is denied. Application may be running in partial trust. Either disable WMI or configure the application to run in full trust.";
	public const string PartialTrustMessageLoggingNotEnabled="Unable to log messages. Application may be running in partial trust. Either disable message logging or configure the application to run in full trust.";
	public const string ScopeNameMustBeSpecified="The 'scopeName' argument to the InstanceKey constructor must be a non-empty string which indicates the scope of uniqueness for the key. Durable services use the service namespace and name as the scope of uniqueness.";
	public const string ProviderCannotBeEmptyString="The 'provider' argument to the InstanceKey constructor must be a non-empty string which identifies the source of the key data. The 'provider' argument can be null, in which case the default correlation provider name is used.";
	public const string CannotSetNameOnTheInvalidKey="The 'Name' property cannot be set on an invalid InstanceKey.";
	public const string UnsupportedMessageQueryResultType="The type {0} is not a supported result type.";
	public const string CannotRepresentResultAsNodeset="The result cannot be represented as a nodeset. Only results of type XPathResultType.NodeSet can be represented as nodesets.";
	public const string MessageNotInLockedState="Message with id {0} was not in a locked state.";
	public const string MessageValidityExpired="Validity of message with id {0} has expired.";
	public const string UnsupportedUpgradeInitiator="The StreamUpgradeInitiator specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeInitiator that was not created by the StreamUpgradeProvider associated with the current IStreamUpgradeChannelBindingProvider  implementation.";
	public const string UnsupportedUpgradeAcceptor="The StreamUpgradeAcceptor specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeAcceptor that was not created by the StreamUpgradeProvider associated with this IStreamUpgradeChannelBindingProvider  implementation.";
	public const string StreamUpgradeUnsupportedChannelBindingKind="The StreamUpgradeProvider {0} does not support the specified ChannelBindingKind ({1}). ";
	public const string ExtendedProtectionNotSupported="Extended protection is not supported on this platform.  Please install the appropriate patch or change the ExtendedProtectionPolicy on the Binding or BindingElement to a value with a PolicyEnforcement value of \"Never\" or \"WhenSupported\".";
	public const string ExtendedProtectionPolicyBasicAuthNotSupported="The Authentication Scheme \"Basic\" does not support Extended Protection.  Please use a different authentication scheme or disable the ExtendedProtectionPolicy on the Binding or BindingElement by creating a new ExtendedProtectionPolicy with a PolicyEnforcement value of \"Never\".";
	public const string ExtendedProtectionPolicyCustomChannelBindingNotSupported="CustomChannelBindings are not supported.  Please remove the CustomChannelBinding from the ExtendedProtectionPolicy\".";
	public const string HttpClientCredentialTypeInvalid="ClientCredentialType '{0}' can only be used on the server side, not the client side. Please use one of the following values instead 'None, Basic, Client, Digest, Ntlm, Windows'.";
	public const string SecurityTokenProviderIncludeWindowsGroupsInconsistent="When authentication schemes 'Basic' and also '{0}' are enabled, the value of IncludeWindowsGroups for Windows ('{1}') and UserName authentication ('{2}') must match. Please consider using the same value in both places.";
	public const string AuthenticationSchemesCannotBeInheritedFromHost="The authentication schemes cannot be inherited from the host for binding '{0}'. No AuthenticationScheme was specified on the ServiceHost or in the virtual application in IIS. This may be resolved by enabling at least one authentication scheme for this virtual application in IIS, through the ServiceHost.Authentication.AuthenticationSchemes property or in the configuration at the <serviceAuthenticationManager> element.";
	public const string AuthenticationSchemes_BindingAndHostConflict="The authentication schemes configured on the host ('{0}') do not allow those configured on the binding '{1}' ('{2}').  Please ensure that the SecurityMode is set to Transport or TransportCredentialOnly.  Additionally, this may be resolved by changing the authentication schemes for this application through the IIS management tool, through the ServiceHost.Authentication.AuthenticationSchemes property, in the application configuration file at the <serviceAuthenticationManager> element, by updating the ClientCredentialType property on the binding, or by adjusting the AuthenticationScheme property on the HttpTransportBindingElement.";
	public const string FlagEnumTypeExpected="Object type must be an enum with the flag attribute. '{0}' is not an enum - or the flag attribute is not set. Please use an enum type with the flag attribute instead.";
	public const string InvalidFlagEnumType="Object type must be an enum with the flag attribute and may only contain powers of two for the flags enum values or a combination of such values. Please use an enum type according to these rules.";
	public const string NoAsyncWritePending="There is no pending asynchronous write on this stream. Ensure that there is pending write on the stream or verify that the implementation does not try to complete the same operation multiple times.";
	public const string FlushBufferAlreadyInUse="Cannot write to a buffer which is currently being flushed. ";
	public const string WriteAsyncWithoutFreeBuffer="An asynchronous write was called on the stream without a free buffer.";
	public const string TransportDoesNotSupportCompression="The transport configured on this binding does not appear to support the CompressionFormat specified ({0}) on the message encoder.  To resolve this issue, set the CompressionFormat on the {1} to '{2}' or use a different transport.";
	public const string UnsupportedSecuritySetting="The value '{1}' is not supported in this context for the binding security property '{0}'.";
	public const string UnsupportedBindingProperty="The value '{1}' is not supported in this context for the binding property '{0}'.";
	public const string HttpMaxPendingAcceptsTooLargeError="The value of MaxPendingAccepts should not be larger than {0}.";
	public const string RequestInitializationTimeoutReached="The initialization process of the request message timed out after {0}. To increase this quota, use the '{1}' property on the '{2}'.";
	public const string UnsupportedTokenImpersonationLevel="The value '{1}' for the '{0}' property is not supported in Windows Store apps.";
	public const string AcksToMustBeSameAsRemoteAddress="The remote endpoint requested an address for acknowledgements that is not the same as the address for application messages. The channel could not be opened because this is not supported. Ensure the endpoint address used to create the channel is identical to the one the remote endpoint was set up with.";
	public const string AcksToMustBeSameAsRemoteAddressReason="The address for acknowledgements must be the same as the address for application messages. Verify that your endpoint is configured to use the same URI for these two addresses.";
	public const string AssertionNotSupported="The {0}:{1} assertion is not supported.";
	public const string ConflictingOffer="The remote endpoint sent conflicting requests to create a reliable session. The remote endpoint requested both a one way and a two way session. The reliable session has been faulted.";
	public const string CouldNotParseWithAction="A message with action {0} could not be parsed.";
	public const string CSRefusedDuplexNoOffer="The endpoint at {0} processes duplex sessions. The create sequence request must contain an offer for a return sequence. This is likely caused by a binding mismatch.";
	public const string CSRefusedInputOffer="The endpoint at {0} processes input sessions. The create sequence request must not contain an offer for a return sequence. This is likely caused by a binding mismatch.";
	public const string CSRefusedReplyNoOffer="The endpoint at {0} processes reply sessions. The create sequence request must contain an offer for a return sequence. This is likely caused by a binding mismatch.";
	public const string CSRefusedUnexpectedElementAtEndOfCSMessage="The message is not a valid SOAP message. The body contains more than 1 root element.";
	public const string CSResponseOfferRejected="The remote endpoint replied to a request for a two way session with an offer for a one way session. This is likely caused by a binding mismatch. The channel could not be opened.";
	public const string CSResponseOfferRejectedReason="The client requested creation of a two way session. A one way session was created. The session cannot continue without as a one way session. This is likely caused by a binding mismatch.";
	public const string CSResponseWithOfferReason="A return sequence was not offered by the create sequence request. The create sequence response cannot accept a return sequence.";
	public const string CSResponseWithoutOfferReason="A return sequence was offered by the create sequence request but the create sequence response did not accept this sequence.";
	public const string DeliveryAssuranceRequiredNothingFound="The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. Nothing was found.";
	public const string DeliveryAssuranceRequired="The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. The {1} element under the {2} namespace was found.";
	public const string EarlyTerminateSequence="The remote endpoint has errantly sent a TerminateSequence protocol message before the sequence finished.";
	public const string ElementFound="The {0}:{1} element requires a {2}:{3} child element but has the {4} child element under the {5} namespace.";
	public const string ElementRequired="The {0}:{1} element requires a {2}:{3} child element but has no child elements.";
	public const string InvalidAcknowledgementFaultReason="The SequenceAcknowledgement violates the cumulative acknowledgement invariant.";
	public const string InvalidWsrmResponseChannelNotOpened="The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel could not be opened.";
	public const string InvalidWsrmResponseSessionFaultedExceptionString="The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel was faulted.";
	public const string LastMessageNumberExceededFaultReason="The value for wsrm:MessageNumber exceeds the value of the MessageNumber accompanying a LastMessage element in this Sequence.";
	public const string ManualAddressingNotSupported="Binding validation failed because the TransportBindingElement's ManualAddressing property was set to true on a binding that is configured to create reliable sessions. This combination is not supported and the channel factory or service host was not opened.";
	public const string MessageExceptionOccurred="A problem occurred while reading a message. See inner exception for details.";
	public const string MessageNumberRolloverFaultReason="The maximum value for wsrm:MessageNumber has been exceeded.";
	public const string MissingMessageIdOnWsrmRequest="The wsa:MessageId header must be present on a wsrm:{0} message.";
	public const string MissingReplyToOnWsrmRequest="The wsa:ReplyTo header must be present on a wsrm:{0} message.";
	public const string NonWsrmFeb2005ActionNotSupported="The action {0} is not supported by this endpoint. Only WS-ReliableMessaging February 2005 messages are processed by this endpoint.";
	public const string ReceivedResponseBeforeRequestFaultString="The {0}Response was received when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session cannot continue.";
	public const string RMEndpointNotFoundReason="The endpoint at {0} has stopped accepting wsrm sessions.";
	public const string SequenceClosedFaultString="The Sequence is closed and cannot accept new messages.";
	public const string SequenceTerminatedAddLastToWindowTimedOut="The RM Source could not transfer the last message within the timeout the user specified.";
	public const string SequenceTerminatedBeforeReplySequenceAcked="The server received a TerminateSequence message before all reply sequence messages were acknowledged. This is a violation of the reply sequence acknowledgement protocol.";
	public const string SequenceTerminatedEarlyTerminateSequence="The wsrm:TerminateSequence protocol message was transmitted before the sequence was successfully completed.";
	public const string SequenceTerminatedInactivityTimeoutExceeded="The inactivity timeout of ({0}) has been exceeded.";
	public const string SequenceTerminatedMaximumRetryCountExceeded="The user specified maximum retry count for a particular message has been exceeded. Because of this the reliable session cannot continue.";
	public const string SequenceTerminatedQuotaExceededException="The necessary size to buffer a sequence message has exceeded the configured buffer quota. Because of this the reliable session cannot continue.";
	public const string SequenceTerminatedReplyMissingAcknowledgement="A reply message was received with no acknowledgement.";
	public const string SequenceTerminatedNotAllRepliesAcknowledged="All of the reply sequence's messages must be acknowledged prior to closing the request sequence. This is a violation of the reply sequence's delivery guarantee. The session cannot continue.";
	public const string SequenceTerminatedSmallLastMsgNumber="The wsrm:LastMsgNumber value is too small. A message with a larger sequence number has already been received.";
	public const string SequenceTerminatedUnexpectedAcknowledgement="The RM destination received an acknowledgement message. The RM destination does not process acknowledgement messages.";
	public const string SequenceTerminatedUnexpectedAckRequested="The RM source received an AckRequested message. The RM source does not process AckRequested messages.";
	public const string SequenceTerminatedUnexpectedCloseSequence="The RM source received an CloseSequence message. The RM source does not process CloseSequence messages.";
	public const string SequenceTerminatedUnexpectedCloseSequenceResponse="The RM destination received an CloseSequenceResponse message. The RM destination does not process CloseSequenceResponse messages.";
	public const string SequenceTerminatedUnexpectedCS="The RM source received a CreateSequence request. The RM source does not process CreateSequence requests.";
	public const string SequenceTerminatedUnexpectedCSOfferId="The RM destination received multiple CreateSequence requests with different OfferId values over the same session.";
	public const string SequenceTerminatedUnexpectedCSR="The RM destination received a CreateSequenceResponse message. The RM destination does not process CreateSequenceResponse messages.";
	public const string SequenceTerminatedUnexpectedCSROfferId="The RM source received multiple CreateSequenceResponse messages with different sequence identifiers over the same session.";
	public const string SequenceTerminatedUnexpectedTerminateSequence="The RM source received a TerminateSequence message. The RM source does not process TerminateSequence messages.";
	public const string SequenceTerminatedUnexpectedTerminateSequenceResponse="The RM destination received a TerminateSequenceResponse message. The RM destination does not process TerminateSequenceResponse messages.";
	public const string SequenceTerminatedUnsupportedTerminateSequence="The RM source does not support an RM destination initiated termination since messages can be lost. The reliable session cannot continue.";
	public const string SequenceTerminatedUnknownAddToWindowError="An unknown error occurred while trying to add a sequence message to the window.";
	public const string TimeoutOnAddToWindow="The message could not be transferred within the allotted timeout of {0}. There was no space available in the reliable channel's transfer window. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string TimeoutOnClose="The close operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string TimeoutOnOpen="The open operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string TimeoutOnOperation="The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string TimeoutOnRequest="The request operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string TimeoutOnSend="The send operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string UnexpectedAcknowledgement="The remote endpoint sent an unexpected ack. Simplex servers do not process acks.";
	public const string UnexpectedAckRequested="The remote endpoint sent an unexpected request for an ack. Simplex clients do not send acks and do not process requests for acks.";
	public const string UnexpectedCloseSequence="The remote endpoint sent an unexpected close sequence message. Simplex clients do not process this message.";
	public const string UnexpectedCloseSequenceResponse="The remote endpoint sent an unexpected close sequence response message. Simplex servers do not process this message.";
	public const string UnexpectedCS="The remote endpoint sent an unexpected request to create a sequence. Clients do not process requests for a sequence.";
	public const string UnexpectedCSR="The remote endpoint sent an unexpected create sequence response. Servers do not process this message.";
	public const string UnexpectedCSOfferId="The remote endpoint sent inconsistent requests to create the same sequence. The OfferId values are not identical.";
	public const string UnexpectedCSROfferId="The remote endpoint sent inconsistent responses to the same create sequence request. The sequence identifiers are not identical.";
	public const string UnexpectedTerminateSequence="The remote endpoint sent an unexpected terminate sequence message. Simplex clients do not process this message.";
	public const string UnexpectedTerminateSequenceResponse="The remote endpoint sent an unexpected terminate sequence response message. Simplex servers do not process this message.";
	public const string UnparsableCSResponse="The remote endpoint replied to the request for a sequence with a response that could not be parsed. See inner exception for details. The channel could not be opened.";
	public const string UnknownSequenceFaultReason="The value of wsrm:Identifier is not a known Sequence identifier.";
	public const string UnknownSequenceMessageReceived="The remote endpoint has sent a message containing an unrecognized sequence identifier. The reliable session was faulted.";
	public const string UnrecognizedFaultReceivedOnOpen="The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The channel could not be opened.";
	public const string WsrmFaultReceived="The sequence has been terminated by the remote endpoint. {0} The reliable session was faulted.";
	public const string WsrmMessageProcessingError="An error occurred while processing a message. {0}";
	public const string WsrmMessageWithWrongRelatesToFaultString="The remote endpoint has responded to a {0} request message with an invalid reply. The reply has a wsa:RelatesTo header with an unexpected identifier. The reliable session cannot continue.";
	public const string WsrmRequestIncorrectReplyToFaultString="The wsrm:{0} request message's wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.";
	public const string WsrmRequiredFaultString="The RM server requires the use of WS-ReliableMessaging 1.1 protocol. This is likely caused by a binding mismatch.";
	public const string SFxActionDemuxerDuplicate="The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.";
	public const string SFxActionMismatch="Cannot create a typed message due to action mismatch, expecting {0} encountered {1}";
	public const string SFxAnonymousTypeNotSupported="Part {1} in message {0} cannot be exported with RPC or encoded since its type is anonymous.";
	public const string SFxAsyncResultsDontMatch0="The IAsyncResult returned from Begin and the IAsyncResult supplied to the Callback are on different objects. These are required to be the same object.";
	public const string SFXBindingNameCannotBeNullOrEmpty="Binding name cannot be null or empty.";
	public const string SFXUnvalidNamespaceValue="Value '{0}' provided for {1} property is an invalid URI.";
	public const string SFXUnvalidNamespaceParam="Parameter value '{0}' is an invalid URI.";
	public const string SFXHeaderNameCannotBeNullOrEmpty="Header name cannot be null or empty.";
	public const string SFxEndpointNoMatchingScheme="Could not find a base address that matches scheme {0} for the endpoint with binding {1}. Registered base address schemes are [{2}].";
	public const string SFxBindingSchemeDoesNotMatch="The scheme '{0}' used by binding {1} does not match the required scheme '{2}'.";
	public const string SFxGetChannelDispatcherDoesNotSupportScheme="Only a '{0}' using '{1}' or '{2}' is supported in this scenario.";
	public const string SFxIncorrectMessageVersion="MessageVersion '{0}' is not supported in this scenario.  Only MessageVersion '{1}' is supported.";
	public const string SFxBindingNotSupportedForMetadataHttpGet="The binding associated with ServiceMetadataBehavior or ServiceDebugBehavior is not supported.  The inner binding elements used by this binding must support IReplyChannel. Verify that HttpGetBinding/HttpsGetBinding (on ServiceMetadataBehavior) and HttpHelpPageBinding/HttpsHelpPageBinding (on ServiceDebugBehavior) are supported.";
	public const string SFxBadByReferenceParameterMetadata="Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.";
	public const string SFxBadByValueParameterMetadata="Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.";
	public const string SFxBadMetadataMustBePolicy="When calling the CreateFromPolicy method, the policy argument must be an XmlElement instance with LocalName '{1}' and NamespaceUri '{0}'. This XmlElement has LocalName '{3}' and NamespaceUri '{2}'. ";
	public const string SFxBadMetadataLocationUri="The URI supplied to ServiceMetadataBehavior via the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in config must be a relative URI or an absolute URI with an http or https scheme. '{0}' was specified, which is a absolute URI with {1} scheme.";
	public const string SFxBadMetadataLocationNoAppropriateBaseAddress="The URL supplied to ServiceMetadataBehavior via the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in config was a relative URL and there is no base address with which to resolve it. '{0}' was specified.";
	public const string SFxBadMetadataDialect="There was a problem reading the MetadataSet argument: a MetadataSection instance with identifier '{0}' and dialect '{1}' has a Metadata property whose type does not match the dialect. The expected Metadata type for this dialect is '{2}' but was found to be '{3}'.";
	public const string SFxBadMetadataReference="Metadata contains a reference that cannot be resolved: '{0}'.";
	public const string SFxMaximumResolvedReferencesOutOfRange="The MaximumResolvedReferences property of MetadataExchangeClient must be greater than or equal to one.  '{0}' was specified.";
	public const string SFxMetadataExchangeClientNoMetadataAddress="The MetadataExchangeClient was not supplied with a MetadataReference or MetadataLocation from which to get metadata.  You must supply one to the constructor, to the GetMetadata method, or to the BeginGetMetadata method.";
	public const string SFxMetadataExchangeClientCouldNotCreateChannelFactory="The MetadataExchangeClient could not create an IChannelFactory for: address='{0}', dialect='{1}', and  identifier='{2}'. ";
	public const string SFxMetadataExchangeClientCouldNotCreateWebRequest="The MetadataExchangeClient could not create an HttpWebRequest for: address='{0}', dialect='{1}', and  identifier='{2}'. ";
	public const string SFxMetadataExchangeClientCouldNotCreateChannelFactoryBadScheme="The MetadataExchangeClient instance could not be initialized because no Binding is available for scheme '{0}'. You can supply a Binding in the constructor, or specify a configurationName.";
	public const string SFxBadTransactionProtocols="The TransactionProtocol setting was not understood. A supported protocol must be specified.";
	public const string SFxMetadataResolverKnownContractsArgumentCannotBeEmpty="The MetadataResolver cannot recieve an empty contracts argument to the Resolve or BeginResolve methods.  You must supply at least one ContractDescription.";
	public const string SFxMetadataResolverKnownContractsUniqueQNames="The ContractDescriptions in contracts must all have unique Name and Namespace pairs.  More than one ContractDescription had the pair Name='{0}' and Namespace='{1}'. ";
	public const string SFxMetadataResolverKnownContractsCannotContainNull="The contracts argument to the Resolve or BeginResolve methods cannot contain a null ContractDescription.";
	public const string SFxBindingDoesNotHaveATransportBindingElement="The binding specified to do metadata exchange does not contain a TransportBindingElement.";
	public const string SFxBindingMustContainTransport2="The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.";
	public const string SFxBodyCannotBeNull="Body object cannot be null in message {0}";
	public const string SFxBodyObjectTypeCannotBeInherited="Type {0} cannot inherit from any class other than object to be used as body object in RPC style.";
	public const string SFxBodyObjectTypeCannotBeInterface="Type {0} implements interface {1} which is not supported for body object in RPC style.";
	public const string SFxCallbackBehaviorAttributeOnlyOnDuplex="CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. Contract '{0}' is not duplex, as it contains no callback operations.";
	public const string SFxCallbackRequestReplyInOrder1="This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.";
	public const string SfxCallbackTypeCannotBeNull="In order to use the contract '{0}' with DuplexChannelFactory, the contract must specify a valid callback contract.  If your contract does not have a callback contract, consider using ChannelFactory instead of DuplexChannelFactory.";
	public const string SFxCannotActivateCallbackInstace="The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.";
	public const string SFxCannotCallAddBaseAddress="ServiceHostBase's AddBaseAddress method cannot be called after the InitializeDescription method has completed.";
	public const string SFxCannotCallAutoOpenWhenExplicitOpenCalled="Cannot make a call on this channel because a call to Open() is in progress.";
	public const string SFxCannotGetMetadataFromRelativeAddress="The MetadataExchangeClient can only get metadata from absolute addresses.  It cannot get metadata from '{0}'.";
	public const string SFxCannotHttpGetMetadataFromAddress="The MetadataExchangeClient can only get metadata from http or https addresses when using MetadataExchangeClientMode HttpGet. It cannot get metadata from '{0}'.";
	public const string SFxCannotGetMetadataFromLocation="The MetadataExchangeClient can only get metadata from http and https MetadataLocations.  It cannot get metadata from '{0}'.";
	public const string SFxCannotHaveDifferentTransactionProtocolsInOneBinding="The configured policy specifies more than one TransactionProtocol across the operations. A single TransactionProtocol for each endpoint must be specified.";
	public const string SFxCannotImportAsParameters_Bare="Generating message contract since the operation {0} is neither RPC nor document wrapped.";
	public const string SFxCannotImportAsParameters_DifferentWrapperNs="Generating message contract since the wrapper namespace ({1}) of message {0} does not match the default value ({2})";
	public const string SFxCannotImportAsParameters_DifferentWrapperName="Generating message contract since the wrapper name ({1}) of message {0} does not match the default value ({2})";
	public const string SFxCannotImportAsParameters_ElementIsNotNillable="Generating message contract since element name {0} from namespace {1} is not marked nillable";
	public const string SFxCannotImportAsParameters_MessageHasProtectionLevel="Generating message contract since message {0} requires protection.";
	public const string SFxCannotImportAsParameters_HeadersAreIgnoredInEncoded="Headers are not supported in RPC encoded format. Headers are ignored in message {0}.";
	public const string SFxCannotImportAsParameters_HeadersAreUnsupported="Generating message contract since message {0} has headers";
	public const string SFxCannotImportAsParameters_Message="Generating message contract since the operation {0} has untyped Message as argument or return type";
	public const string SFxCannotImportAsParameters_NamespaceMismatch="Generating message contract since message part namespace ({0}) does not match the default value ({1})";
	public const string SFxCannotRequireBothSessionAndDatagram3="There are two contracts listening on the same binding ({2}) and address with conflicting settings.  Specifically, the contract '{0}' specifies SessionMode.NotAllowed while the contract '{1}' specifies SessionMode.Required.  You should either change one of the SessionMode values or specify a different address (or ListenUri) for each endpoint.";
	public const string SFxCannotSetExtensionsByIndex="This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.";
	public const string SFxChannelDispatcherDifferentHost0="This ChannelDispatcher is not currently attached to the provided ServiceHost.";
	public const string SFxChannelDispatcherMultipleHost0="Cannot add a ChannelDispatcher to more than one ServiceHost.";
	public const string SFxChannelDispatcherNoHost0="Cannot open ChannelDispatcher because it is not attached to a ServiceHost.";
	public const string SFxChannelDispatcherNoMessageVersion="Cannot open ChannelDispatcher because it is does not have a MessageVersion set.";
	public const string SFxChannelDispatcherUnableToOpen1="The ChannelDispatcher at '{0}' is unable to open its IChannelListener as there are no endpoints for the ChannelDispatcher.";
	public const string SFxChannelDispatcherUnableToOpen2="The ChannelDispatcher at '{0}' with contract(s) '{1}' is unable to open its IChannelListener.";
	public const string SFxChannelFactoryTypeMustBeInterface="The type argument passed to the generic ChannelFactory class must be an interface type.";
	public const string SFxChannelFactoryCannotApplyConfigurationWithoutEndpoint="ApplyConfiguration requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the ApplyConfiguration method to provide an alternative implementation.";
	public const string SFxChannelFactoryCannotCreateFactoryWithoutDescription="CreateFactory requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the CreateFactory method to provide an alternative implementation.";
	public const string SFxClientOutputSessionAutoClosed="This channel can no longer be used to send messages as the output session was auto-closed due to a server-initiated shutdown. Either disable auto-close by setting the DispatchRuntime.AutomaticInputSessionShutdown to false, or consider modifying the shutdown protocol with the remote server.";
	public const string SFxCodeGenArrayTypeIsNotSupported="Array of type {0} is not supported.";
	public const string SFxCodeGenCanOnlyStoreIntoArgOrLocGot0="Can only store into ArgBuilder or LocalBuilder. Got: {0}.";
	public const string SFxCodeGenExpectingEnd="Expecting End {0}.";
	public const string SFxCodeGenIsNotAssignableFrom="{0} is not assignable from {1}.";
	public const string SFxCodeGenNoConversionPossibleTo="No conversion possible to {0}.";
	public const string SFxCodeGenWarning="CODEGEN: {0}";
	public const string SFxCodeGenUnknownConstantType="Internal Error: Unrecognized constant type {0}.";
	public const string SFxCollectionDoesNotSupportSet0="This collection does not support setting items by index.";
	public const string SFxCollectionReadOnly="This operation is not supported because the collection is read-only.";
	public const string SFxCollectionWrongType2="The collection of type {0} does not support values of type {1}.";
	public const string SFxConflictingGlobalElement="Top level XML element with name {0} in namespace {1} cannot reference {2} type because it already references a different type ({3}). Use a different operation name or MessageBodyMemberAttribute to specify a different name for the Message or Message parts.";
	public const string SFxConflictingGlobalType="Duplicate top level XML Schema type with name {0} in namespace {1}.";
	public const string SFxContextModifiedInsideScope0="The value of OperationContext.Current is not the OperationContext value installed by this OperationContextScope.";
	public const string SFxContractDescriptionNameCannotBeEmpty="ContractDescription's Name must be a non-empty string.";
	public const string SFxContractHasZeroOperations="ContractDescription '{0}' has zero operations; a contract must have at least one operation.";
	public const string SFxContractHasZeroInitiatingOperations="ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.";
	public const string SFxContractInheritanceRequiresInterfaces="The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.";
	public const string SFxContractInheritanceRequiresInterfaces2="The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.";
	public const string SFxCopyToRequiresICollection="SynchronizedReadOnlyCollection's CopyTo only works if the underlying list implements ICollection.";
	public const string SFxCreateDuplexChannel1="The callback contract of contract {0} either does not exist or does not define any operations.  If this is not a duplex contract, consider using ChannelFactory instead of DuplexChannelFactory.";
	public const string SFxCreateDuplexChannelNoCallback="This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was not initialized with an InstanceContext.  Please call the CreateChannel overload that takes an InstanceContext.";
	public const string SFxCreateDuplexChannelNoCallback1="This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided.  Please call the CreateChannel overload that takes an InstanceContext.";
	public const string SFxCreateDuplexChannelNoCallbackUserObject="This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.";
	public const string SFxCreateDuplexChannelBadCallbackUserObject="The InstanceContext provided to the ChannelFactory contains a UserObject that does not implement the CallbackContractType '{0}'.";
	public const string SFxCreateNonDuplexChannel1="ChannelFactory does not support the contract {0} as it defines a callback contract with one or more operations.  Please consider using DuplexChannelFactory instead of ChannelFactory.";
	public const string SFxCustomBindingNeedsTransport1="The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.";
	public const string SFxCustomBindingWithoutTransport="The Scheme cannot be computed for this binding because this CustomBinding lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.";
	public const string SFxDeserializationFailed1="The formatter threw an exception while trying to deserialize the message: {0}";
	public const string SFxDictionaryIsEmpty="This operation is not possible since the dictionary is empty.";
	public const string SFxDisallowedAttributeCombination="The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.";
	public const string SFxEndpointAddressNotSpecified="The endpoint's address is not specified. ";
	public const string SFxEndpointContractNotSpecified="The endpoint's contract is not specified.";
	public const string SFxEndpointBindingNotSpecified="The endpoint's binding is not specified.";
	public const string SFxInitializationUINotCalled="The channel is configured to use interactive initializer '{0}', but the channel was Opened without calling DisplayInitializationUI.  Call DisplayInitializationUI before calling Open or other methods on this channel.";
	public const string SFxInitializationUIDisallowed="AllowInitializationUI was set to false for this channel, but the channel is configured to use the '{0}' as an interactive initializer.";
	public const string SFxDocExt_NoMetadataSection1="This is a Windows&#169; Communication Foundation service.<BR/><BR/><B>Metadata publishing for this service is currently disabled.</B><BR/><BR/>If you have access to the service, you can enable metadata publishing by completing the following steps to modify your web or application configuration file:<BR/><BR/>1. Create the following service behavior configuration, or add the &lt;serviceMetadata&gt; element to an existing service behavior configuration:";
	public const string SFxDocExt_NoMetadataSection2="2. Add the behavior configuration to the service:";
	public const string SFxDocExt_NoMetadataSection3="Note: the service name must match the configuration name for the service implementation.<BR/><BR/>3. Add the following endpoint to your service configuration:";
	public const string SFxDocExt_NoMetadataSection4="Note: your service must have an http base address to add this endpoint.<BR/><BR/>The following is an example service configuration file with metadata publishing enabled:";
	public const string SFxDocExt_NoMetadataSection5="For more information on publishing metadata please see the following documentation: <a href=\"http://go.microsoft.com/fwlink/?LinkId=65455\">http://go.microsoft.com/fwlink/?LinkId=65455</a>.";
	public const string SFxDocExt_NoMetadataConfigComment1="Note: the service name must match the configuration name for the service implementation.";
	public const string SFxDocExt_NoMetadataConfigComment2="Add the following endpoint. ";
	public const string SFxDocExt_NoMetadataConfigComment3="Note: your service must have an http base address to add this endpoint.";
	public const string SFxDocExt_NoMetadataConfigComment4="Add the following element to your service behavior configuration.";
	public const string SFxDocExt_CS="<P class='intro'><B>C#</B></P>";
	public const string SFxDocExt_VB="<P class='intro'><B>Visual Basic</B></P>";
	public const string SFxDocExt_MainPageTitleNoServiceName="Service";
	public const string SFxDocExt_MainPageTitle="{0} Service";
	public const string SFxDocExt_MainPageIntro1a="You have created a service.<P class='intro'>To test this service, you will need to create a client and use it to call the service. You can do this using the svcutil.exe tool from the command line with the following syntax:</P> ";
	public const string SFxDocExt_MainPageIntro1b="You have created a service.<P class='intro'>To test this service, you will need to create a client and use it to call the service; however, metadata publishing via ?WSDL is currently disabled. This can be enabled via the service's configuration file. </P>";
	public const string SFxDocExt_MainPageIntro2="This will generate a configuration file and a code file that contains the client class. Add the two files to your client application and use the generated client class to call the Service. For example:<BR/>";
	public const string SFxDocExt_MainPageComment="Use the 'client' variable to call operations on the service.";
	public const string SFxDocExt_MainPageComment2="Always close the client.";
	public const string SFxDocExt_Error="The service encountered an error.";
	public const string SFxDocEncodedNotSupported="Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.";
	public const string SFxDocEncodedFaultNotSupported="Fault could not be loaded as the Use setting is Encoded and it references a schema definition using Element attribute. To fix the problem, change the Use setting to Literal.";
	public const string SFxDuplicateMessageParts="Message part {0} in namespace {1} appears more than once in Message.";
	public const string SFxDuplicateInitiatingActionAtSameVia="This service has multiple endpoints listening at '{0}' which share the same initiating action '{1}'.  As a result, messages with this action would be dropped since the dispatcher would not be able to determine the correct endpoint for handling the message.  Please consider hosting these Endpoints at separate ListenUris.";
	public const string SFXEndpointBehaviorUsedOnWrongSide="The IEndpointBehavior '{0}' cannot be used on the server side; this behavior can only be applied to clients.";
	public const string SFxEndpointDispatcherMultipleChannelDispatcher0="Cannot add EndpointDispatcher to more than one ChannelDispatcher.";
	public const string SFxEndpointDispatcherDifferentChannelDispatcher0="This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.";
	public const string SFxErrorCreatingMtomReader="Error creating a reader for the MTOM message";
	public const string SFxErrorDeserializingRequestBody="Error in deserializing body of request message for operation '{0}'.";
	public const string SFxErrorDeserializingRequestBodyMore="Error in deserializing body of request message for operation '{0}'. {1}";
	public const string SFxErrorDeserializingReplyBody="Error in deserializing body of reply message for operation '{0}'.";
	public const string SFxErrorDeserializingReplyBodyMore="Error in deserializing body of reply message for operation '{0}'. {1}";
	public const string SFxErrorSerializingBody="There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.";
	public const string SFxErrorDeserializingHeader="There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.";
	public const string SFxErrorSerializingHeader="There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.";
	public const string SFxErrorDeserializingFault="Server returned an invalid SOAP Fault.  Please see InnerException for more details.";
	public const string SFxErrorReflectingOnType2="An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.";
	public const string SFxErrorReflectingOnMethod3="An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.";
	public const string SFxErrorReflectingOnParameter4="An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.";
	public const string SFxErrorReflectionOnUnknown1="An error occurred while loading attribute '{0}'.  Please see InnerException for more details.";
	public const string SFxExceptionDetailEndOfInner="--- End of inner ExceptionDetail stack trace ---";
	public const string SFxExceptionDetailFormat="An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:";
	public const string SFxExpectedIMethodCallMessage="Internal Error: Message must be a valid IMethodCallMessage.";
	public const string SFxExportMustHaveType="The specified ContractDescription could not be exported to WSDL because the Type property of the MessagePartDescription with name '{1}' in the OperationDescription with name '{0}' is not set.  The Type property must be set in order to create WSDL.";
	public const string SFxFaultCannotBeImported="Fault named {0} in operation {1} cannot be imported. {2}";
	public const string SFxFaultContractDuplicateDetailType="In operation {0}, more than one fault is declared with detail type {1}";
	public const string SFxFaultContractDuplicateElement="In operation {0}, more than one fault is declared with element name {1} in namespace {2}";
	public const string SFxFaultExceptionToString3="{0}: {1} (Fault Detail is equal to {2}).";
	public const string SFxFaultReason="The creator of this fault did not specify a Reason.";
	public const string SFxFaultTypeAnonymous="In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.";
	public const string SFxHeaderNameMismatchInMessageContract="Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.";
	public const string SFxHeaderNameMismatchInOperation="Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.";
	public const string SFxHeaderNamespaceMismatchInMessageContract="Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.";
	public const string SFxHeaderNamespaceMismatchInOperation="Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.";
	public const string SFxHeaderNotUnderstood="The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding. ";
	public const string SFxHeadersAreNotSupportedInEncoded="Message {0} must not have headers to be used in RPC encoded style.";
	public const string SFxImmutableServiceHostBehavior0="This value cannot be changed after the ServiceHost has opened.";
	public const string SFxImmutableChannelFactoryBehavior0="This value cannot be changed after the ChannelFactory has opened.";
	public const string SFxImmutableClientBaseCacheSetting="This value cannot be changed after the first ClientBase of type '{0}' has been created.";
	public const string SFxImmutableThrottle1="{0} cannot be changed after the ServiceHost has opened.";
	public const string SFxInconsistentBindingBodyParts="Operation {0} binding {1} has extra part {2} that is not present in other bindings";
	public const string SFxInconsistentWsdlOperationStyleInHeader="Style {1} on header {0} does not match expected style {2}.";
	public const string SFxInconsistentWsdlOperationStyleInMessageParts="All parts of message in operation {0} must either contain type or element. ";
	public const string SFxInconsistentWsdlOperationStyleInOperationMessages="Style {1} inferred from messages in operation {0} does not match expected style {2} specified via bindings.";
	public const string SFxInconsistentWsdlOperationUseAndStyleInBinding="Bindings for operation {0} cannot specify different use and style values. Binding {1} specifies use {2} and style {3} while binding {4} specifies use {5} and style {6}.";
	public const string SFxInconsistentWsdlOperationUseInBindingExtensions="Extensions for operation {0} in binding {1} cannot specify different use values.";
	public const string SFxInconsistentWsdlOperationUseInBindingMessages="Message bindings for operation {0} in binding {1} cannot specify different use values.";
	public const string SFxInconsistentWsdlOperationUseInBindingFaults="Fault bindings for operation {0} in binding {1} cannot specify different use values.";
	public const string SFxInputParametersToServiceInvalid="Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.";
	public const string SFxInputParametersToServiceNull="Service implementation object invoked with null input parameters, but operation expects {0} parameters.";
	public const string SFxInstanceNotInitialized="The InstanceContext has no provider for creating Service implementation objects.";
	public const string SFxInterleavedContextScopes0="This OperationContextScope is being disposed out of order.";
	public const string SFxInternalServerError="The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the <serviceDebug> configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.";
	public const string SFxInternalCallbackError="The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the <clientDebug> configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the client trace logs.";
	public const string SFxInvalidAsyncResultState0="IAsyncResult's State must be the state argument passed to your Begin call.";
	public const string SFxInvalidCallbackIAsyncResult="IAsyncResult not provided or of wrong type.";
	public const string SFxInvalidCallbackContractType="The CallbackContract {0} is invalid because it is not an interface type.";
	public const string SFxInvalidChannelToOperationContext="Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.";
	public const string SFxInvalidContextScopeThread0="This OperationContextScope is being disposed on a different thread than it was created.";
	public const string SFxInvalidMessageBody="OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'";
	public const string SFxInvalidMessageBodyEmptyMessage="The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).";
	public const string SFxInvalidMessageBodyErrorSerializingParameter="There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.";
	public const string SFxInvalidMessageBodyErrorDeserializingParameter="There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.";
	public const string SFxInvalidMessageBodyErrorDeserializingParameterMore="There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.";
	public const string SFxInvalidMessageContractSignature="The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.";
	public const string SFxInvalidMessageHeaderArrayType="MessageHeaderArrayAttribute found on member {0} is not a single dimensional array.";
	public const string SFxInvalidRequestAction="Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.";
	public const string SFxInvalidReplyAction="Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.";
	public const string SFxInvalidStreamInTypedMessage="In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.";
	public const string SFxInvalidStreamInRequest="For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.";
	public const string SFxInvalidStreamInResponse="For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.";
	public const string SFxInvalidStreamOffsetLength="Buffer size must be at least {0} bytes.";
	public const string SFxInvalidUseOfPrimitiveOperationFormatter="The PrimitiveOperationFormatter was given a parameter or return type which it does not support.";
	public const string SFxInvalidStaticOverloadCalledForDuplexChannelFactory1="The static CreateChannel method cannot be used with the contract {0} because that contract defines a callback contract.  Please try using one of the static CreateChannel overloads on DuplexChannelFactory<TChannel>.";
	public const string SFxInvalidSoapAttribute="XmlSerializer attribute {0} is not valid in {1}. Only SoapElement attribute is supported.";
	public const string SFxInvalidXmlAttributeInBare="XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.";
	public const string SFxInvalidXmlAttributeInWrapped="XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.";
	public const string SFxKnownTypeAttributeInvalid1="{0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type";
	public const string SFxKnownTypeAttributeReturnType3="The return type of method {1} in type {2} must be IEnumerable<Type> to be used by ServiceKnownTypeAttribute in {0}";
	public const string SFxKnownTypeAttributeUnknownMethod3="ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}";
	public const string SFxKnownTypeNull="KnownType cannot be null in operation {0}";
	public const string SFxMessageContractBaseTypeNotValid="The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.";
	public const string SFxMessageContractRequiresDefaultConstructor="The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.";
	public const string SFxMessageOperationFormatterCannotSerializeFault="MessageOperationFormatter cannot serialize faults.";
	public const string SFxMetadataReferenceInvalidLocation="The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.";
	public const string SFxMethodNotSupported1="Method {0} is not supported on this proxy, this can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.";
	public const string SFxMethodNotSupportedOnCallback1="Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.";
	public const string SFxMethodNotSupportedByType2="ServiceHost implementation type {0} does not implement ServiceContract {1}.";
	public const string SFxMismatchedOperationParent="A DispatchOperation (or ClientOperation) can only be added to its parent DispatchRuntime (or ClientRuntime).";
	public const string SFxMissingActionHeader="No Action header was found with namespace '{0}' for the given message.";
	public const string SFxMultipleCallbackFromSynchronizationContext="Calling Post() on '{0}' resulted in multiple callbacks.  This indicates a problem in '{0}'.";
	public const string SFxMultipleCallbackFromAsyncOperation="The callback passed to operation '{0}' was called more than once.  This indicates an internal error in the implementation of that operation.";
	public const string SFxMultipleUnknownHeaders="Method {0} in type {1} has more than one header part of type array of XmlElement.";
	public const string SFxMultipleContractStarOperations0="A ServiceContract has more the one operation with an Action of \"*\".  A ServiceContract can have at most one operation an Action = \"*\".";
	public const string SFxMultipleContractsWithSameName="The Service contains multiple ServiceEndpoints with different ContractDescriptions which each have Name='{0}' and Namespace='{1}'.  Either provide ContractDescriptions with unique Name and Namespaces, or ensure the ServiceEndpoints have the same ContractDescription instance.";
	public const string SFxMultiplePartsNotAllowedInEncoded="Part {1}:{0} is repeating and is not supported in Soap Encoding.";
	public const string SFxNameCannotBeEmpty="The Name property must be a non-empty string.";
	public const string SFxConfigurationNameCannotBeEmpty="The ConfigurationName property must be a non-empty string.";
	public const string SFxNeedProxyBehaviorOperationSelector2="Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.";
	public const string SFxNoDefaultConstructor="The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or pass an instance of the type to the host.";
	public const string SFxNoMostDerivedContract="The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.";
	public const string SFxNullReplyFromExtension2="Extension {0} prevented call to operation '{1}' from replying by setting the reply to null.";
	public const string SFxNullReplyFromFormatter2="Formatter {0} returned a null reply message for call to operation '{1}'.";
	public const string SFxServiceChannelIdleAborted="The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.";
	public const string SFxServiceMetadataBehaviorUrlMustBeHttpOrRelative="{0} must be a relative URI or an absolute URI with scheme '{1}'.  '{2}' is an absolute URI with scheme '{3}'. ";
	public const string SFxServiceMetadataBehaviorNoHttpBaseAddress="The HttpGetEnabled property of ServiceMetadataBehavior is set to true and the HttpGetUrl property is a relative address, but there is no http base address.  Either supply an http base address or set HttpGetUrl to an absolute address.";
	public const string SFxServiceMetadataBehaviorNoHttpsBaseAddress="The HttpsGetEnabled property of ServiceMetadataBehavior is set to true and the HttpsGetUrl property is a relative address, but there is no https base address.  Either supply an https base address or set HttpsGetUrl to an absolute address.";
	public const string SFxServiceMetadataBehaviorInstancingError="The ChannelDispatcher with ListenUri '{0}' has endpoints with the following contracts: {1}. Metadata endpoints cannot share ListenUris. The conflicting endpoints were either specified in AddServiceEndpoint() calls, in a config file, or a combination of AddServiceEndpoint() and config.";
	public const string SFxServiceTypeNotCreatable="Service implementation type is an interface or abstract class and no implementation object was provided.";
	public const string SFxSetEnableFaultsOnChannelDispatcher0="This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.";
	public const string SFxSetManualAddresssingOnChannelDispatcher0="This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.";
	public const string SFxNoBatchingForSession="TransactedBatchingBehavior validation failed. Service or client cannot be started. Transacted batching is not supported for session contracts. Remove transacted batching behavior from the endpoint or define a non-sessionful contract.";
	public const string SFxNoBatchingForReleaseOnComplete="TransactedBatchingBehavior validation failed. Service cannot be started. Transacted batching requires ServiceBehavior.ReleaseServiceInstanceOnTransactionComplete to be false.";
	public const string SFxNoServiceObject="The service implementation object was not initialized or is not available.";
	public const string SFxNone2004="The WS-Addressing \"none\" value is not valid for the August 2004 version of WS-Addressing.";
	public const string SFxNonExceptionThrown="An object that is not an exception was thrown.";
	public const string SFxNonInitiatingOperation1="The operation '{0}' cannot be the first operation to be called because IsInitiating is false.";
	public const string SfxNoTypeSpecifiedForParameter="There was no CLR type specified for parameter {0}, preventing the operation from being generated.";
	public const string SFxOneWayAndTransactionsIncompatible="The one-way operation '{1}' on ServiceContract '{0}' is configured for transaction flow. Transactions cannot be flowed over one-way operations.";
	public const string SFxOneWayMessageToTwoWayMethod0="The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.";
	public const string SFxOperationBehaviorAttributeOnlyOnServiceClass="OperationBehaviorAttribute can only go on the service class, it cannot be put on the ServiceContract interface. Method '{0}' on type '{1}' violates this.";
	public const string SFxOperationBehaviorAttributeReleaseInstanceModeDoesNotApplyToCallback="The ReleaseInstanceMode property on OperationBehaviorAttribute can only be set on non-callback operations. Method '{0}' violates this.";
	public const string SFxOperationContractOnNonServiceContract="Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.";
	public const string SFxOperationContractProviderOnNonServiceContract="Method '{1}' has {0}, but enclosing type '{2}' does not have ServiceContractAttribute. {0} can only be used on methods in ServiceContractAttribute types.";
	public const string SFxOperationDescriptionNameCannotBeEmpty="OperationDescription's Name must be a non-empty string.";
	public const string SFxParameterNameCannotBeNull="All parameter names used in operations that make up a service contract must not be null.";
	public const string SFxOperationMustHaveOneOrTwoMessages="OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.";
	public const string SFxParameterCountMismatch="There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.";
	public const string SFxParameterMustBeMessage="The 'parameters' argument must be an array that contains a single Message object.";
	public const string SFxParametersMustBeEmpty="The 'parameters' argument must be either null or an empty array.";
	public const string SFxParameterMustBeArrayOfOneElement="The 'parameters' argument must be an array of one element.";
	public const string SFxPartNameMustBeUniqueInRpc="Message part name {0} is not unique in an RPC Message.";
	public const string SFxReceiveContextSettingsPropertyMissing="The contract '{0}' has at least one operation annotated with '{1}', but the binding used for the contract endpoint at address '{2}' does not support required binding property '{3}'. Please ensure that the binding used for the contract supports the ReceiveContext capability.";
	public const string SFxReceiveContextPropertyMissing="Required message property '{0}' is missing from the IncomingProperties collections of the received message. Ensure that when the receive context is enabled on the binding, the created channel ensures that '{0}' is present on all received messages.";
	public const string SFxRequestHasInvalidReplyToOnClient="The request message has ReplyTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting ReplyTo on the message.";
	public const string SFxRequestHasInvalidFaultToOnClient="The request message has FaultTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting FaultTo on the message.";
	public const string SFxRequestHasInvalidFromOnClient="The request message has From='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting From on the message.";
	public const string SFxRequestHasInvalidReplyToOnServer="The request message has ReplyTo='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.";
	public const string SFxRequestHasInvalidFaultToOnServer="The request message has FaultTo='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.";
	public const string SFxRequestHasInvalidFromOnServer="The request message has From='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.";
	public const string SFxRequestReplyNone="A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the \"None\" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of \"None.\"";
	public const string SFxRequestTimedOut1="This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.";
	public const string SFxRequestTimedOut2="This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.";
	public const string SFxReplyActionMismatch3="A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.";
	public const string SFxRequiredRuntimePropertyMissing="Required runtime property '{0}' is not initialized on DispatchRuntime. Do not remove ServiceBehaviorAttribute from ServiceDescription.Behaviors or ensure that you include a third-party service behavior that supplies this value.";
	public const string SFxResolvedMaxResolvedReferences="The MetadataExchangeClient has resolved more than MaximumResolvedReferences.";
	public const string SFxResultMustBeMessage="The 'result' argument must be of type Message.";
	public const string SFxRevertImpersonationFailed0="Could not revert impersonation on current thread. Continuing would compromise system security. Terminating process.";
	public const string SFxRpcMessageBodyPartNameInvalid="RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}";
	public const string SFxRpcMessageMustHaveASingleBody="RPC Message {1} in operation {0} must have a single MessageBodyMember.";
	public const string SFxSchemaDoesNotContainElement="There was a problem loading the XSD documents provided: a reference to a schema element with name '{0}' and namespace '{1}' could not be resolved because the element definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.";
	public const string SFxSchemaDoesNotContainType="There was a problem loading the XSD documents provided: a reference to a schema type with name '{0}' and namespace '{1}' could not be resolved because the type definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.";
	public const string SFxWsdlMessageDoesNotContainPart3="Service description message '{1}' from target namespace '{2}' does not contain part named '{0}'.";
	public const string SFxSchemaNotFound="Schema with target namespace '{0}' could not be found.";
	public const string SFxSecurityContextPropertyMissingFromRequestMessage="SecurityContextProperty is missing from the request Message, this may indicate security is configured incorrectly.";
	public const string SFxServerDidNotReply="The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.";
	public const string SFxServiceHostBaseCannotAddEndpointAfterOpen="Endpoints cannot be added after the ServiceHost has been opened/faulted/aborted/closed.";
	public const string SFxServiceHostBaseCannotAddEndpointWithoutDescription="Endpoints cannot be added before the Description property has been initialized.";
	public const string SFxServiceHostBaseCannotApplyConfigurationWithoutDescription="ApplyConfiguration requires that the Description property be initialized. Either provide a valid ServiceDescription in the CreateDescription method or override the ApplyConfiguration method to provide an alternative implementation.";
	public const string SFxServiceHostBaseCannotLoadConfigurationSectionWithoutDescription="LoadConfigurationSection requires that the Description property be initialized. Provide a valid ServiceDescription in the CreateDescription method.";
	public const string SFxServiceHostBaseCannotInitializeRuntimeWithoutDescription="InitializeRuntime requires that the Description property be initialized. Either provide a valid ServiceDescription in the CreateDescription method or override the InitializeRuntime method to provide an alternative implementation.";
	public const string SFxServiceHostCannotCreateDescriptionWithoutServiceType="InitializeDescription must be called with a serviceType or singletonInstance parameter.";
	public const string SFxStaticMessageHeaderPropertiesNotAllowed="Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader<T>.";
	public const string SFxStreamIOException="An exception has been thrown when reading the stream.";
	public const string SFxStreamRequestMessageClosed="The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.";
	public const string SFxStreamResponseMessageClosed="The message containing this stream has been closed. ";
	public const string SFxThrottleLimitMustBeGreaterThanZero0="Throttle limit must be greater than zero. To disable, set to Int32.MaxValue.";
	public const string SFxTimeoutInvalidStringFormat="The timeout value provided was not of a recognized format.  Please see InnerException for more details.";
	public const string SFxTimeoutOutOfRange0="Timeout must be greater than or equal to TimeSpan.Zero. To disable timeout, specify TimeSpan.MaxValue.";
	public const string SFxTimeoutOutOfRangeTooBig="Timeouts larger than Int32.MaxValue TotalMilliseconds (approximately 24 days) cannot be honored. To disable timeout, specify TimeSpan.MaxValue.";
	public const string SFxTooManyPartsWithSameName="Cannot create a unique part name for {0}.";
	public const string SFxTraceCodeElementIgnored="An unrecognized element was encountered in the XML during deserialization which was ignored.";
	public const string SfxTransactedBindingNeeded="TransactedBatchingBehavior validation failed. The service endpoint cannot be started. TransactedBatchingBehavior requires a binding that contains a binding element ITransactedBindingElement that returns true for ITransactedBindingElement.TransactedReceiveEnabled. If you are using NetMsmqBinding or MsmqIntegrationBinding make sure that ExactlyOnce is set to true.";
	public const string SFxTransactionNonConcurrentOrAutoComplete2="TThe operation '{1}' on contract '{0}' is configured with TransactionAutoComplete set to false and with ConcurrencyMode not set to Single. TransactionAutoComplete set to false requires ConcurrencyMode.Single.";
	public const string SFxTransactionNonConcurrentOrReleaseServiceInstanceOnTxComplete="The '{0}' service is configured with ReleaseServiceInstanceOnTransactionComplete set to true, but the ConcurrencyMode is not set to Single. The ReleaseServiceInstanceOnTransactionComplete requires the use of ConcurrencyMode.Single.";
	public const string SFxNonConcurrentOrEnsureOrderedDispatch="The '{0}' service is configured with EnsureOrderedDispatch set to true, but the ConcurrencyMode is not set to Single. EnsureOrderedDispatch requires the use of ConcurrencyMode.Single.";
	public const string SfxDispatchRuntimeNonConcurrentOrEnsureOrderedDispatch="The DispatchRuntime.EnsureOrderedDispatch property is set to true, but the DispatchRuntime.ConcurrencyMode is not set to Single. EnsureOrderedDispatch requires the use of ConcurrencyMode.Single.";
	public const string SFxTransactionsNotSupported="The service does not support concurrent transactions.";
	public const string SFxTransactionAsyncAborted="The transaction under which this method call was executing was asynchronously aborted.";
	public const string SFxTransactionInvalidSetTransactionComplete="The SetTransactionComplete method was called in the operation '{0}' on contract '{1}' when TransactionAutoComplete was set to true. The SetTransactionComplete method can only be called when TransactionAutoComplete is set to false. This is an invalid scenario and the current transaction was aborted.";
	public const string SFxMultiSetTransactionComplete="The SetTransactionComplete method was wrongly called more than once in the operation '{0}' on contract '{1}'. The SetTransactionComplete method can only be called once. This is an invalid scenario and the current transaction was aborted.";
	public const string SFxTransactionFlowAndMSMQ="The binding for the endpoint at address '{0}' is configured with both the MsmqTransportBindingElement and the TransactionFlowBindingElement. These two elements cannot be used together.";
	public const string SFxTransactionAutoCompleteFalseAndInstanceContextMode="The operation '{1}' on contract '{0}' is configured with TransactionAutoComplete set to false and the InstanceContextMode is not set to PerSession. TransactionAutoComplete set to false requires the use of InstanceContextMode.PerSession.";
	public const string SFxTransactionAutoCompleteFalseOnCallbackContract="The operation '{0}' on callback contract '{1}' is configured with TransactionAutoComplete set to false. TransactionAutoComplete set to false cannot be used with operations on callback contracts.";
	public const string SFxTransactionAutoCompleteFalseAndSupportsSession="The operation '{1}' on contract '{0}' is configured with TransactionAutoComplete set to false but SessionMode is not set to Required. TransactionAutoComplete set to false requires SessionMode.Required.";
	public const string SFxTransactionAutoCompleteOnSessionCloseNoSession="The service '{0}' is configured with TransactionAutoCompleteOnSessionClose set to true and with an InstanceContextMode not set to PerSession. TransactionAutoCompleteOnSessionClose set to true requires an instancing mode that uses sessions.";
	public const string SFxTransactionTransactionTimeoutNeedsScope="The service '{0}' is configured with a TransactionTimeout but no operations are configured with TransactionScopeRequired set to true. TransactionTimeout requires at least one operation with TransactionScopeRequired set to true.";
	public const string SFxTransactionIsolationLevelNeedsScope="The service '{0}' is configured with a TransactionIsolationLevel but no operations are configured with TransactionScopeRequired set to true. TransactionIsolationLevel requires at least one operation with TransactionScopeRequired set to true.";
	public const string SFxTransactionReleaseServiceInstanceOnTransactionCompleteNeedsScope="The service '{0}' is configured with ReleaseServiceInstanceOnTransactionComplete but no operations are configured with TransactionScopeRequired set to true. The ReleaseServiceInstanceOnTransactionComplete property requires at least one operation with TransactionScopeRequired set to true. Remove the ReleaseServiceInstanceOnTransactionComplete property from the service if this is the case.";
	public const string SFxTransactionTransactionAutoCompleteOnSessionCloseNeedsScope="The service '{0}' is configured with TransactionAutoCompleteOnSessionClose, but no operations are configured with TransactionScopeRequired set to true. The TransactionAutoCompleteOnSessionClose property requires at least one operation with TransactionScopeRequired set to true. Remove the TransactionAutoCompleteOnSessionClose property from the service if this is the case.";
	public const string SFxTransactionFlowRequired="The service operation requires a transaction to be flowed.";
	public const string SFxTransactionUnmarshalFailed="The flowed transaction could not be unmarshaled. The following exception occurred: {0}";
	public const string SFxTransactionDeserializationFailed="The incoming transaction cannot be deserialized. The transaction header in the message was either malformed or in an unrecognized format. The client and the service must be configured to use the same protocol and protocol version. The following exception occurred: {0}";
	public const string SFxTransactionHeaderNotUnderstood="The transaction header '{0}' within the namespace '{1}' was not understood by the service. The client and the service must be configured to use the same protocol and protocol version ('{2}').";
	public const string SFxTryAddMultipleTransactionsOnMessage="An attempt was made to add more than one transaction to a message. At most one transaction can be added.";
	public const string SFxTypedMessageCannotBeNull="Internal Error: The instance of the MessageContract cannot be null in {0}.";
	public const string SFxTypedMessageCannotBeRpcLiteral="The operation '{0}' could not be loaded because it specifies \"rpc-style\" in \"literal\" mode, but uses message contract types or the System.ServiceModel.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.";
	public const string SFxTypedOrUntypedMessageCannotBeMixedWithParameters="The operation '{0}' could not be loaded because it has a parameter or return type of type System.ServiceModel.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.";
	public const string SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc="When using the rpc-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.";
	public const string SFxUnknownFaultNoMatchingTranslation1="This fault did not provide a matching translation: {0}";
	public const string SFxUnknownFaultNullReason0="This fault did not provide a reason (MessageFault.Reason was null).";
	public const string SFxUnknownFaultZeroReasons0="This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).";
	public const string SFxUserCodeThrewException="User operation '{0}.{1}' threw an exception that is unhandled in user code. This exception will be rethrown. If this is a recurring problem, it may indicate an error in the implementation of the '{0}.{1}' method.";
	public const string SfxUseTypedMessageForCustomAttributes="Parameter '{0}' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is '{1}'.";
	public const string SFxWellKnownNonSingleton0="In order to use one of the ServiceHost constructors that takes a service instance, the InstanceContextMode of the service must be set to InstanceContextMode.Single.  This can be configured via the ServiceBehaviorAttribute.  Otherwise, please consider using the ServiceHost constructors that take a Type argument.";
	public const string SFxVersionMismatchInOperationContextAndMessage2="Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.";
	public const string SFxWhenMultipleEndpointsShareAListenUriTheyMustHaveSameIdentity="When multiple endpoints on a service share the same ListenUri, those endpoints must all have the same Identity in their EndpointAddress. The endpoints at ListenUri '{0}' do not meet this criteria.";
	public const string SFxWrapperNameCannotBeEmpty="Wrapper element name cannot be empty.";
	public const string SFxWrapperTypeHasMultipleNamespaces="Wrapper type for message {0} cannot be projected as a data contract type since it has multiple namespaces. Consider using the XmlSerializer";
	public const string SFxWsdlPartMustHaveElementOrType="WSDL part {0} in message {1} from namespace {2} must have either an element or a type name";
	public const string SFxDataContractSerializerDoesNotSupportBareArray="DataContractSerializer does not support collection specified on element '{0}' ";
	public const string SFxDataContractSerializerDoesNotSupportEncoded="Invalid OperationFormatUse specified in the OperationFormatStyle of operation {0}, DataContractSerializer supports only Literal.";
	public const string SFxXmlArrayNotAllowedForMultiple="XmlArrayAttribute cannot be used in repeating part {1}:{0}.";
	public const string SFxXmlSerializerIsNotFound="Could not find XmlSerializer for type {0}.";
	public const string SFxConfigContractNotFound="Could not find default endpoint element that references contract '{0}' in the ServiceModel client configuration section. This might be because no configuration file was found for your application, or because no endpoint element matching this contract could be found in the client element.";
	public const string SFxConfigChannelConfigurationNotFound="Could not find endpoint element with name '{0}' and contract '{1}' in the ServiceModel client configuration section. This might be because no configuration file was found for your application, or because no endpoint element matching this name could be found in the client element.";
	public const string SFxChannelFactoryEndpointAddressUri="The Address property on ChannelFactory.Endpoint was null.  The ChannelFactory's Endpoint must have a valid Address specified.";
	public const string SFxServiceContractGeneratorConfigRequired="In order to generate configuration information using the GenerateServiceEndpoint method, the ServiceContractGenerator instance must have been initialized with a valid Configuration object.";
	public const string SFxCloseTimedOut1="The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.";
	public const string SfxCloseTimedOutWaitingForDispatchToComplete="Close process timed out waiting for service dispatch to complete.";
	public const string SFxInvalidWsdlBindingOpMismatch2="The WSDL binding named {0} is not valid because no match for operation {1} was found in the corresponding portType definition.";
	public const string SFxInvalidWsdlBindingOpNoName="The WSDL binding named {0} is not valid because an operation binding doesn't have a name specified.";
	public const string SFxChannelFactoryNoBindingFoundInConfig1="The underlying channel factory could not be created because no binding information was found in the configuration file for endpoint with name '{0}'.  Please check the endpoint configuration section with name '{0}' to ensure that binding information is present and correct.";
	public const string SFxChannelFactoryNoBindingFoundInConfigOrCode="The underlying channel factory could not be created because no Binding was passed to the ChannelFactory. Please supply a valid Binding instance via the ChannelFactory constructor.";
	public const string SFxConfigLoaderMultipleEndpointMatchesSpecified2="The endpoint configuration section for contract '{0}' with name '{1}' could not be loaded because more than one endpoint configuration with the same name and contract were found. Please check your config and try again.";
	public const string SFxConfigLoaderMultipleEndpointMatchesWildcard1="An endpoint configuration section for contract '{0}' could not be loaded because more than one endpoint configuration for that contract was found. Please indicate the preferred endpoint configuration section by name.";
	public const string SFxProxyRuntimeMessageCannotBeNull="In operation '{0}', cannot pass null to methods that take Message as input parameter.";
	public const string SFxDispatchRuntimeMessageCannotBeNull="In operation '{0}', cannot return null from methods that return Message.";
	public const string SFxServiceHostNeedsClass="ServiceHost only supports class service types.";
	public const string SfxReflectedContractKeyNotFound2="The contract name '{0}' could not be found in the list of contracts implemented by the service '{1}'.";
	public const string SfxReflectedContractKeyNotFoundEmpty="In order to add an endpoint to the service '{0}', a non-empty contract name must be specified.";
	public const string SfxReflectedContractKeyNotFoundIMetadataExchange="The contract name 'IMetadataExchange' could not be found in the list of contracts implemented by the service {0}.  Add a ServiceMetadataBehavior to the configuration file or to the ServiceHost directly to enable support for this contract.";
	public const string SfxServiceContractAttributeNotFound="The contract type {0} is not attributed with ServiceContractAttribute.  In order to define a valid contract, the specified type (either contract interface or service class) must be attributed with ServiceContractAttribute.";
	public const string SfxReflectedContractsNotInitialized1="An endpoint for type '{0}' could not be added because the ServiceHost instance was not initialized properly.  In order to add endpoints by Type, the CreateDescription method must be called.  If you are using a class derived from ServiceHost, ensure that the class is properly calling base.CreateDescription.";
	public const string SFxMessagePartDescriptionMissingType="Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.";
	public const string SFxWsdlOperationInputNeedsMessageAttribute2="The wsdl operation input {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.";
	public const string SFxWsdlOperationOutputNeedsMessageAttribute2="The wsdl operation output {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.";
	public const string SFxWsdlOperationFaultNeedsMessageAttribute2="The wsdl operation {0} in portType {1} contains a fault that does not reference a message. This is either because the message attribute is missing or empty.";
	public const string SFxMessageContractAttributeRequired="Cannot create a typed message from type '{0}'.  The functionality only valid for types decorated with MessageContractAttribute.";
	public const string AChannelServiceEndpointIsNull0="A Channel/Service Endpoint is null.";
	public const string AChannelServiceEndpointSBindingIsNull0="A Channel/Service endpoint's Binding is null.";
	public const string AChannelServiceEndpointSContractIsNull0="A Channel/Service endpoint's Contract is null.";
	public const string AChannelServiceEndpointSContractSNameIsNull0="A Channel/Service endpoint's Contract's name is null or empty.";
	public const string AChannelServiceEndpointSContractSNamespace0="A Channel/Service endpoint's Contract's namespace is null.";
	public const string ServiceHasZeroAppEndpoints="Service '{0}' has zero application (non-infrastructure) endpoints. This might be because no configuration file was found for your application, or because no service element matching the service name could be found in the configuration file, or because no endpoints were defined in the service element.";
	public const string BindingRequirementsAttributeRequiresQueuedDelivery1="DeliveryRequirementsAttribute requires QueuedDelivery, but binding for the endpoint with contract '{0}' doesn't support it or isn't configured properly to support it.";
	public const string BindingRequirementsAttributeDisallowsQueuedDelivery1="DeliveryRequirementsAttribute disallows QueuedDelivery, but binding for the endpoint with contract '{0}' supports it.";
	public const string SinceTheBindingForDoesnTSupportIBindingCapabilities1_1="The DeliveryRequirementsAttribute on contract '{0}' specifies that the binding must support ordered delivery (RequireOrderedDelivery).  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.";
	public const string SinceTheBindingForDoesnTSupportIBindingCapabilities2_1="The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements constraint.  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.";
	public const string TheBindingForDoesnTSupportOrderedDelivery1="The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements value of NotAllowed.  However, the configured binding for this contract specifies that it does support queued delivery.  A queued binding may not be used with this contract.";
	public const string ChannelHasAtLeastOneOperationWithTransactionFlowEnabled="At least one operation on the '{0}' contract is configured with the TransactionFlowAttribute attribute set to Mandatory but the channel's binding '{1}' is not configured with a TransactionFlowBindingElement. The TransactionFlowAttribute attribute set to Mandatory cannot be used without a TransactionFlowBindingElement.";
	public const string ServiceHasAtLeastOneOperationWithTransactionFlowEnabled="At least one operation on the '{0}' contract is configured with the TransactionFlowAttribute attribute set to Mandatory but the channel's binding '{1}' is not configured with a TransactionFlowBindingElement. The TransactionFlowAttribute attribute set to Mandatory cannot be used without a TransactionFlowBindingElement.";
	public const string SFxNoEndpointMatchingContract="The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).";
	public const string SFxNoEndpointMatchingAddress="The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.";
	public const string SFxNoEndpointMatchingAddressForConnectionOpeningMessage="The message with Action '{0}' cannot be processed at the receiver because this Action is reserved for the connection opening messages only and cannot be sent from client to server. To invoke this operation on the server, call the '{1}' method on the client proxy instead.";
	public const string SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled="The operation '{0}' could not be invoked because the property '{1}' on the OperationContract is set to '{2}'. To invoke this operation on the server, call the '{3}' method on the client proxy instead.";
	public const string EndMethodsCannotBeDecoratedWithOperationContractAttribute="When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.";
	public const string WsatMessagingInitializationFailed="The WS-AT messaging library failed to initialize.";
	public const string WsatProxyCreationFailed="A client-side channel to the WS-AT protocol service could not be created.";
	public const string DispatchRuntimeRequiresFormatter0="The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.";
	public const string ClientRuntimeRequiresFormatter0="The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.";
	public const string RuntimeRequiresInvoker0="DispatchOperation requires Invoker.";
	public const string CouldnTCreateChannelForType2="Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.";
	public const string CouldnTCreateChannelForChannelType2="Channel type '{1}' was requested, but Binding '{0}' doesn't support it or isn't configured properly to support it.";
	public const string EndpointListenerRequirementsCannotBeMetBy3="ChannelDispatcher requirements cannot be met by the IChannelListener for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding only supports these channel types '{2}'.";
	public const string UnknownListenerType1="The listener at Uri '{0}' could not be initialized because it was created for an unrecognized channel type.";
	public const string BindingDoesnTSupportSessionButContractRequires1="Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.";
	public const string BindingDoesntSupportDatagramButContractRequires="Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.";
	public const string BindingDoesnTSupportOneWayButContractRequires1="Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.";
	public const string BindingDoesnTSupportTwoWayButContractRequires1="Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.";
	public const string BindingDoesnTSupportRequestReplyButContract1="Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.";
	public const string BindingDoesnTSupportDuplexButContractRequires1="Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.";
	public const string BindingDoesnTSupportAnyChannelTypes1="Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. ";
	public const string ContractIsNotSelfConsistentItHasOneOrMore2="The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.";
	public const string ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled="The operation contract '{0}' is not self-consistent. When the '{1}' is set to '{2}', both '{3}' and '{4}' properties must be true, and the operation must not have any input parameters.";
	public const string InstanceSettingsMustHaveTypeOrWellKnownObject0="The ServiceHost must be configured with either a serviceType or a serviceInstance.  Both of these values are currently null.";
	public const string TheServiceMetadataExtensionInstanceCouldNot2_0="The ServiceMetadataExtension instance could not be added to the ServiceHost instance because it has already been added to another ServiceHost instance.";
	public const string TheServiceMetadataExtensionInstanceCouldNot3_0="The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has not been added to any ServiceHost instance.";
	public const string TheServiceMetadataExtensionInstanceCouldNot4_0="The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has already been added to a different ServiceHost instance.";
	public const string SynchronizedCollectionWrongType1="A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.";
	public const string SynchronizedCollectionWrongTypeNull="A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.";
	public const string CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0="Cannot add two items with the same key to SynchronizedKeyedCollection.";
	public const string ItemDoesNotExistInSynchronizedKeyedCollection0="Item does not exist in SynchronizedKeyedCollection.";
	public const string SuppliedMessageIsNotAReplyItHasNoRelatesTo0="A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.";
	public const string channelIsNotAvailable0="Internal Error: The InnerChannel property is null.";
	public const string channelDoesNotHaveADuplexSession0="The current channel does not support closing the output session as this channel does not implement ISessionChannel<IDuplexSession>.";
	public const string EndpointsMustHaveAValidBinding1="The ServiceEndpoint with name '{0}' could not be exported to WSDL because the Binding property is null. To fix this, set the Binding property to a valid Binding instance.";
	public const string ABindingInstanceHasAlreadyBeenAssociatedTo1="A binding instance has already been associated to listen URI '{0}'. If two endpoints want to share the same ListenUri, they must also share the same binding object instance. The two conflicting endpoints were either specified in AddServiceEndpoint() calls, in a config file, or a combination of AddServiceEndpoint() and config. ";
	public const string UnabletoImportPolicy="The following Policy Assertions were not Imported:\r\n";
	public const string UnImportedAssertionList="   XPath:{0}\r\n  Assertions:";
	public const string XPathUnavailable="\"XPath Unavailable\"";
	public const string DuplicatePolicyInWsdlSkipped="A policy expression was ignored because another policy expression with that ID has already been read in this document.\r\nXPath:{0}";
	public const string DuplicatePolicyDocumentSkipped="A policy document was ignored because a policy expression with that ID has already been imported.\r\nPolicy ID:{0}";
	public const string PolicyDocumentMustHaveIdentifier="A metadata section containing policy did not have an identifier so it cannot be referenced. ";
	public const string XPathPointer="XPath:{0}";
	public const string UnableToFindPolicyWithId="A policy reference was ignored because the policy with ID '{0}' could not be found.";
	public const string PolicyReferenceInvalidId="A policy reference was ignored because the URI of the reference was empty.";
	public const string PolicyReferenceMissingURI="A policy reference was ignored because the required {0} attribute was missing.";
	public const string ExceededMaxPolicyComplexity="The policy expression was not fully imported because it exceeded the maximum allowable complexity. The import stopped at element '{0}' '{1}'.";
	public const string ExceededMaxPolicySize="The policy expression was not fully imported because its normalized form was too large.";
	public const string UnrecognizedPolicyElementInNamespace="Unrecognized policy element {0} in namespace {1}.";
	public const string UnsupportedPolicyDocumentRoot="\"{0}\" is not a supported WS-Policy document root element.";
	public const string UnrecognizedPolicyDocumentNamespace="The \"{0}\" namespace is not a recognized WS-Policy namespace.";
	public const string NoUsablePolicyAssertions="Cannot find usable policy alternatives.";
	public const string PolicyInWsdlMustHaveFragmentId="Unreachable policy detected.\r\nA WS-Policy element embedded in WSDL is missing a fragment identifier. This policy cannot be referenced by any WS-PolicyAttachment mechanisms.\r\nXPath:{0}";
	public const string FailedImportOfWsdl="The processing of the WSDL parameter failed. Error: {0}";
	public const string OptionalWSDLExtensionIgnored="The optional WSDL extension element '{0}' from namespace '{1}' was not handled.\r\nXPath: {2}";
	public const string RequiredWSDLExtensionIgnored="The required WSDL extension element '{0}' from namespace '{1}' was not handled.";
	public const string UnknownWSDLExtensionIgnored="An unrecognized WSDL extension of Type '{0}' was not handled.";
	public const string WsdlExporterIsFaulted="A previous call to this WsdlExporter left it in a faulted state. It is no longer usable.";
	public const string WsdlImporterIsFaulted="A previous call to this WsdlImporter left it in a faulted state. It is no longer usable.";
	public const string WsdlImporterContractMustBeInKnownContracts="The ContractDescription argument to ImportEndpoints must be contained in the KnownContracts collection.";
	public const string WsdlItemAlreadyFaulted="A previous attempt to import this {0} already failed.";
	public const string InvalidPolicyExtensionTypeInConfig="The type {0} registered as a policy extension does not implement IPolicyImportExtension";
	public const string PolicyExtensionTypeRequiresDefaultConstructor="The type {0} registered as a policy extension does not have a public default constructor. Policy extensions must have a public default constructor";
	public const string PolicyExtensionImportError="An exception was thrown in a call to a policy import extension.\r\nExtension: {0}\r\nError: {1}";
	public const string PolicyExtensionExportError="An exception was thrown in a call to a policy export extension.\r\nExtension: {0}\r\nError: {1}";
	public const string MultipleCallsToExportContractWithSameContract="Calling IWsdlExportExtension.ExportContract twice with the same ContractDescription is not supported.";
	public const string DuplicateContractQNameNameOnExport="Duplicate contract XmlQualifiedNames are not supported.\r\nAnother ContractDescription with the Name: {0} and Namespace: {1} has already been exported.";
	public const string WarnDuplicateBindingQNameNameOnExport="Similar ServiceEndpoints were exported. The WSDL export process was forced to suffix wsdl:binding names to avoid naming conflicts.\r\n Similar ServiceEndpoints means different binding instances having the Name: {0} and Namespace: {1} and either the same ContractDescription or at least the same contract Name: {2}.";
	public const string WarnSkippingOpertationWithWildcardAction="An operation was skipped during export because it has a wildcard action. This is not supported in WSDL.\r\nContract Name:{0}\r\nContract Namespace:{1}\r\nOperation Name:{2}";
	public const string WarnSkippingOpertationWithSessionOpenNotificationEnabled="An operation was skipped during export because the property '{0}' is set to '{1}'. This operation should be used for server only and should not be exposed from WSDL. \r\nContract Name:{2}\r\nContract Namespace:{3}\r\nOperation Name:{4}";
	public const string InvalidWsdlExtensionTypeInConfig="The type {0} registered as a WSDL extension does not implement IWsdlImportExtension.";
	public const string WsdlExtensionTypeRequiresDefaultConstructor="The type {0} registered as a WSDL extension does not have a public default constructor. WSDL extensions must have a public default constructor.";
	public const string WsdlExtensionContractExportError="An exception was thrown in a call to a WSDL export extension: {0}\r\n contract: {1}";
	public const string WsdlExtensionEndpointExportError="An exception was thrown in a call to a WSDL export extension: {0}\r\n Endpoint: {1}";
	public const string WsdlExtensionBeforeImportError="A WSDL import extension threw an exception during the BeforeImport call: {0}\r\nError: {1}";
	public const string WsdlExtensionImportError="An exception was thrown while running a WSDL import extension: {0}\r\nError: {1}";
	public const string WsdlImportErrorMessageDetail="Cannot import {0}\r\nDetail: {2}\r\nXPath to Error Source: {1}";
	public const string WsdlImportErrorDependencyDetail="There was an error importing a {0} that the {1} is dependent on.\r\nXPath to {0}: {2}";
	public const string UnsupportedEnvelopeVersion="The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.";
	public const string NoValue0="No value.";
	public const string UnsupportedBindingElementClone="The '{0}' binding element does not support cloning.";
	public const string UnrecognizedBindingAssertions1="WsdlImporter encountered unrecognized policy assertions in ServiceDescription '{0}':";
	public const string ServicesWithoutAServiceContractAttributeCan2="The {0} declared on method '{1}' in type '{2}' is invalid. {0}s are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{2}' or remove {0} from method '{1}'.";
	public const string tooManyAttributesOfTypeOn2="Too many attributes of type {0} on {1}.";
	public const string couldnTFindRequiredAttributeOfTypeOn2="Couldn't find required attribute of type {0} on {1}.";
	public const string AttemptedToGetContractTypeForButThatTypeIs1="Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.";
	public const string NoEndMethodFoundForAsyncBeginMethod3="OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.";
	public const string MoreThanOneEndMethodFoundForAsyncBeginMethod3="OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.";
	public const string InvalidAsyncEndMethodSignatureForMethod2="Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.";
	public const string InvalidAsyncBeginMethodSignatureForMethod2="Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.";
	public const string InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo="Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.";
	public const string InAContractInheritanceHierarchyTheServiceContract3_2="In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.";
	public const string CannotHaveTwoOperationsWithTheSameName3="Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.";
	public const string CannotHaveTwoOperationsWithTheSameElement5="The {0}.{1} operation references a message element [{2}] that has already been exported from the {3}.{4} operation. You can change the name of one of the operations by changing the method name or using the Name property of OperationContractAttribute. Alternatively, you can control the element name in greater detail using the MessageContract programming model.";
	public const string CannotInheritTwoOperationsWithTheSameName3="Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.";
	public const string SyncAsyncMatchConsistency_Parameters5="The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. ";
	public const string SyncTaskMatchConsistency_Parameters5="The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. ";
	public const string TaskAsyncMatchConsistency_Parameters5="The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.";
	public const string SyncAsyncMatchConsistency_ReturnType5="The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. ";
	public const string SyncTaskMatchConsistency_ReturnType5="The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{2}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. ";
	public const string TaskAsyncMatchConsistency_ReturnType5="The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. ";
	public const string SyncAsyncMatchConsistency_Attributes6="The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. ";
	public const string SyncTaskMatchConsistency_Attributes6="The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, any additional attributes must be declared on the synchronous OperationContract method. In this case, the task-based asynchronous OperationContract method '{2}' has one or more attributes of type '{4}'. To fix it, remove the '{4}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. ";
	public const string TaskAsyncMatchConsistency_Attributes6="The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the task-based asynchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. ";
	public const string SyncAsyncMatchConsistency_Property6="The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. ";
	public const string SyncTaskMatchConsistency_Property6="The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract  method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must have the same value for the '{4}' property. In this case, the values are different. To fix it, change the '{4} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. ";
	public const string TaskAsyncMatchConsistency_Property6="The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. ";
	public const string ServiceOperationsMarkedWithIsOneWayTrueMust0="Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.";
	public const string OneWayOperationShouldNotSpecifyAReplyAction1="One way operation {0} cannot not specify a reply action.";
	public const string OneWayAndFaultsIncompatible2="The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.";
	public const string OnlyMalformedMessagesAreSupported="Only malformed Messages are supported.";
	public const string UnableToLocateOperation2="Cannot locate operation {0} in Contract {1}.";
	public const string UnsupportedWSDLOnlyOneMessage="Unsupported WSDL, only one message part is supported for fault messages. This fault message references zero or more than one message part. If you have edit access to the WSDL file, you can fix the problem by removing the extra message parts such that fault message references just one part.";
	public const string UnsupportedWSDLTheFault="Unsupported WSDL, the fault message part must reference an element. This fault message does not reference an element. If you have edit access to the WSDL document, you can fix the problem by referencing a schema element using the 'element' attribute.";
	public const string AsyncEndCalledOnWrongChannel="Async End called on wrong channel.";
	public const string AsyncEndCalledWithAnIAsyncResult="Async End called with an IAsyncResult from a different Begin method.";
	public const string IsolationLevelMismatch2="The received transaction has an isolation level of '{0}' but the service is configured with a TransactionIsolationLevel of '{1}'. The isolation level for received transactions and the service must be the same.";
	public const string MessageHeaderIsNull0="The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.";
	public const string MessagePropertiesArraySize0="The array passed does not have enough space to hold all the properties contained by this collection.";
	public const string DuplicateBehavior1="The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.";
	public const string CantCreateChannelWithManualAddressing="Cannot create channel for a contract that requires request/reply and a binding that requires manual addressing but only supports duplex communication.";
	public const string XsdMissingRequiredAttribute1="Missing required '{0}' attribute.";
	public const string IgnoreSoapHeaderBinding3="Ignoring invalid SOAP header extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}";
	public const string IgnoreSoapFaultBinding3="Ignoring invalid SOAP fault extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}";
	public const string IgnoreMessagePart3="Ignoring invalid part in wsdl:message name='{0}' from targetNamespace='{1}'. Reason: {2}";
	public const string CannotImportPrivacyNoticeElementWithoutVersionAttribute="PrivacyNotice element must have a Version attribute.";
	public const string PrivacyNoticeElementVersionAttributeInvalid="PrivacyNotice element Version attribute must have an integer value.";
	public const string XDCannotFindValueInDictionaryString="Cannot find '{0}' value in dictionary string.";
	public const string WmiGetObject="WMI GetObject Query: {0}";
	public const string WmiPutInstance="WMI PutInstance Class: {0}";
	public const string ObjectMustBeOpenedToDequeue="Cannot dequeue a '{0}' object while in the Created state.";
	public const string NoChannelBuilderAvailable="The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory or a ChannelListener because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.";
	public const string InvalidBindingScheme="The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.";
	public const string CustomBindingRequiresTransport="Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.";
	public const string TransportBindingElementMustBeLast="In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.";
	public const string MessageVersionMissingFromBinding="None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty<MessageVersion> method.";
	public const string NotAllBindingElementsBuilt="Some of the binding elements in this binding were not used when building the ChannelFactory / ChannelListener.  This may be have been caused by the binding elements being misordered.  The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last.  The following binding elements were not built: {0}.";
	public const string MultipleMebesInParameters="More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple MessageEncodingBindingElements in a CustomBinding. Remove all but one of these elements.";
	public const string MultipleStreamUpgradeProvidersInParameters="More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.";
	public const string SecurityCapabilitiesMismatched="The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.";
	public const string BaseAddressMustBeAbsolute="Only an absolute Uri can be used as a base address.";
	public const string BaseAddressDuplicateScheme="This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection. If your service is being hosted in IIS you can fix the problem by setting 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' to true or specifying 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.";
	public const string BaseAddressCannotHaveUserInfo="A base address cannot contain a Uri user info section.";
	public const string TransportBindingElementNotFound="The binding does not contain a TransportBindingElement.";
	public const string ChannelDemuxerBindingElementNotFound="The binding does not contain a ChannelDemuxerBindingElement.";
	public const string BaseAddressCannotHaveQuery="A base address cannot contain a Uri query string.";
	public const string BaseAddressCannotHaveFragment="A base address cannot contain a Uri fragment.";
	public const string UriMustBeAbsolute="The given URI must be absolute.";
	public const string BindingProtocolMappingNotDefined="The binding for scheme '{0}' specified in the protocol mapping does not exist and must be created.";
	public const string Default="(Default)";
	public const string AdminMTAWorkerThreadException="MTAWorkerThread exception";
	public const string InternalError="An unexpected error has occurred.";
	public const string ClsidNotInApplication="The CLSID specified in the service file is not configured in the specified application. (The CLSID is {0}, the AppID is {1}.)";
	public const string ClsidNotInConfiguration="The CLSID specified in the service file does not have a service element in a configuration file. (The CLSID is {0}.)";
	public const string EndpointNotAnIID="An endpoint configured for the COM+ CLSID {0} is not a configured interface on the class. (The contract type is {1}.)";
	public const string ServiceStringFormatError="The COM+ string in the .svc file was formatted incorrectly. (The string is \"{0}\".)";
	public const string ContractTypeNotAnIID="The contract type name in the configuration file was not in the form of an interface identifier. (The string is \"{0}\".)";
	public const string ApplicationNotFound="The configured application was not found. (The Application ID was {0}.)";
	public const string NoVoteIssued=" A transaction vote request was completed, but there was no outstanding vote request.";
	public const string FailedToConvertTypelibraryToAssembly="Failed to convert type library to assembly";
	public const string BadInterfaceVersion="Incorrect Interface version in registry";
	public const string FailedToLoadTypeLibrary="Failed to load type library";
	public const string NativeTypeLibraryNotAllowed=" An attempt to load the native type library '{0}' was made. Native type libraries cannot be loaded.";
	public const string InterfaceNotFoundInAssembly="Could not find interface in the Assembly";
	public const string UdtNotFoundInAssembly="The '{0}' user-defined type could not be found. Ensure that the correct type and type library are registered and specified.";
	public const string UnknownMonikerKeyword="Could not find keyword {0}.";
	public const string MonikerIncorectSerializer="Invalid serializer specified. The only valid values are 'xml' and 'datacontract'.";
	public const string NoEqualSignFound="The keyword '{0}' has no equal sign following it. Ensure that each keyword is followed by an equal sign and a value. ";
	public const string KewordMissingValue="No value found for a keyword.";
	public const string BadlyTerminatedValue="Badly terminated value {0}.";
	public const string MissingQuote="Missing Quote in value {0}.";
	public const string RepeatedKeyword="Repeated moniker keyword.";
	public const string InterfaceNotFoundInConfig="Interface {0} not found in configuration.";
	public const string CannotHaveNullOrEmptyNameOrNamespaceForIID="Interface {0} has a null namespace or name.";
	public const string MethodGivenInConfigNotFoundOnInterface="Method {0} given in config was not found on interface {1}.";
	public const string MonikerIncorrectServerIdentityForMex="Only one type of server identity can be specified.";
	public const string MonikerAddressNotSpecified="Address not specified.";
	public const string MonikerMexBindingSectionNameNotSpecified="Mex binding section name attribute not specified.";
	public const string MonikerMexAddressNotSpecified="Mex address not specified.";
	public const string MonikerContractNotSpecified="Contract not specified.";
	public const string MonikerBindingNotSpecified="Binding not specified.";
	public const string MonikerBindingNamespacetNotSpecified="Binding namespace not specified.";
	public const string MonikerFailedToDoMexRetrieve="Failed to do mex retrieval:{0}.";
	public const string MonikerContractNotFoundInRetreivedMex="None of the contract in metadata matched the contract specified.";
	public const string MonikerNoneOfTheBindingMatchedTheSpecifiedBinding="The contract does not have an endpoint supporting the binding specified.";
	public const string MonikerMissingColon="Moniker Missing Colon";
	public const string MonikerIncorrectServerIdentity="Multiple server identity keywords were specified. Ensure that at most one identity keyword is specified.";
	public const string NoInterface="The object does not support the interface '{0}'.";
	public const string DuplicateTokenExFailed="Could not duplicate the token (error=0x{0:X}).";
	public const string AccessCheckFailed="Could not perform an AccessCheck (error=0x{0:X}).";
	public const string ImpersonateAnonymousTokenFailed="Could not impersonate the anonymous user (error=0x{0:X}).";
	public const string OnlyByRefVariantSafeArraysAllowed="The provided SafeArray parameter was passed by value. SafeArray parameters must be passed by reference.";
	public const string OnlyOneDimensionalSafeArraysAllowed=" Multi-dimensional SafeArray parameters cannot be used.";
	public const string OnlyVariantTypeElementsAllowed="The elements of the SafeArray must be of the type VARIANT.";
	public const string OnlyZeroLBoundAllowed="The lower bound of the SafeArray was not zero. SafeArrays with a lower bound other than zero cannot be used.";
	public const string OpenThreadTokenFailed="Could not open the thread token (error=0x{0:X}).";
	public const string OpenProcessTokenFailed="Could not open the process token (error=0x{0:X}).";
	public const string InvalidIsolationLevelValue="The isolation level for component {0} is invalid. (The value was {1}.)";
	public const string UnsupportedConversion="The conversion between the client parameter type '{0}' to the required server parameter type '{1}' cannot be performed.";
	public const string FailedProxyProviderCreation="The required outer proxy could not be created. Ensure that the service moniker is correctly installed and registered.";
	public const string UnableToLoadDll="Cannot load library {0}. Ensure that WCF is properly installed.";
	public const string InterfaceNotRegistered="Interface Not Registered";
	public const string BadInterfaceRegistration="Bad Interface Registration";
	public const string NoTypeLibraryFoundForInterface="No type library available for interface";
	public const string VariantArrayNull="Parameter at index {0} is null.";
	public const string UnableToRetrievepUnk="Unable to retrieve IUnknown for object.";
	public const string PersistWrapperIsNull="QueryInterface succeeded but the persistable type wrapper was null.";
	public const string UnexpectedThreadingModel="Unexpected threading model. WCF/COM+ integration only supports STA and MTA threading models.";
	public const string NoneOfTheMethodsForInterfaceFoundInConfig="None of the methods were found for interface {0}.";
	public const string InvalidWebServiceInterface="The interface with IID {0} cannot be exposed as a web service";
	public const string InvalidWebServiceParameter="The parameter named {0} of type {1} on method {2} of interface {3} cannot be serialized.";
	public const string InvalidWebServiceReturnValue="The return value of type {0} on method {1} of interface {2} cannot be serialized.";
	public const string OperationNotFound="The method '{0}' could not be found. Ensure that the correct method name is specified.";
	public const string BadDispID="The Dispatch ID '{0}' could not be found or is invalid.";
	public const string BadParamCount="The number of parameters in the request did not match the number supported by the method. Ensure that the correct number of parameters are specified.";
	public const string BindingNotFoundInConfig="Binding type {0} instance {1} not found in config.";
	public const string AddressNotSpecified="The required address keyword was not specified.";
	public const string BindingNotSpecified="The required binding keyword was not specified or is not valid.";
	public const string OnlyVariantAllowedByRef="A VARIANT parameter was passed by value. VARIANT parameters must be passed by reference.";
	public const string CannotResolveTypeForParamInMessageDescription="The type for the '{0}' parameter in '{1}' within the namespace '{2}' cannot not be resolved.";
	public const string TooLate="The operation cannot be performed after the communications channel has been created.";
	public const string RequireConfiguredMethods="The interface with IID {0} has no methods configured in the COM+ catalog and cannot be exposed as a web service.";
	public const string RequireConfiguredInterfaces="The interface with IID {0} is not configured in the COM+ catalog and cannot be exposed as a web service.";
	public const string CannotCreateChannelOption="The channeloption intrinsic object cannot be created because the channel builder is not initialized.";
	public const string NoTransactionInContext="There is no transaction in the context of the operation.";
	public const string IssuedTokenFlowNotAllowed="The service does not accept issued tokens.";
	public const string GeneralSchemaValidationError="There was an error verifying some XML Schemas generated during export:\r\n{0}";
	public const string SchemaValidationError="There was a validation error on a schema generated during export:\r\n    Source: {0}\r\n    Line: {1} Column: {2}\r\n   Validation Error: {3}";
	public const string ContractBindingAddressCannotBeNull="The Address, Binding and Contract keywords are required.";
	public const string TypeLoadForContractTypeIIDFailedWith="Type load for contract interface ID {0} failed with Error:{1}.";
	public const string BindingLoadFromConfigFailedWith="Fail to load binding {0} from config. Error:{1}.";
	public const string PooledApplicationNotSupportedForComplusHostedScenarios="Application {0} is marked Pooled. Pooled applications are not supported under COM+ hosting.";
	public const string RecycledApplicationNotSupportedForComplusHostedScenarios="Application {0} has recycling enabled. Recycling of applications is not supported under COM+ hosting.";
	public const string BadImpersonationLevelForOutOfProcWas="The client token at least needs to have the SecurityImpersonationLevel of at least Impersonation for Out of process Webhost activations.";
	public const string ComPlusInstanceProviderRequiresMessage0="This InstanceContext requires a valid Message to obtain the instance.";
	public const string ComPlusInstanceCreationRequestSchema="From: {0}\nAppId: {1}\nClsId: {2}\nIncoming TransactionId: {3}\nRequesting Identity: {4}";
	public const string ComPlusMethodCallSchema="From: {0}\nAppId: {1}\nClsId: {2}\nIid: {3}\nAction: {4}\nInstance Id: {5}\nManaged Thread Id: {6}\nUnmanaged Thread Id: {7}\nRequesting Identity: {8}";
	public const string ComPlusServiceSchema="AppId: {0}\nClsId: {1}\n";
	public const string ComPlusServiceSchemaDllHost="AppId: {0}";
	public const string ComPlusTLBImportSchema="Iid: {0}\nType Library ID: {1}";
	public const string ComPlusServiceHostStartingServiceErrorNoQFE="A Windows hotfix or later service pack is required on Windows XP and Windows Server 2003 to use WS-AtomicTransaction and COM+ Integration Web service transaction functionality. See the Microsoft .NET Framework release notes for instructions on installing the required hotfix.";
	public const string ComIntegrationManifestCreationFailed="Generating manifest file {0} failed with {1}.";
	public const string TempDirectoryNotFound="Directory {0} not found.";
	public const string CannotAccessDirectory="Cannot access directory {0}.";
	public const string CLSIDDoesNotSupportIPersistStream="The object with CLSID '{0}' does not support the required IPersistStream interface.";
	public const string CLSIDOfTypeDoesNotMatch="CLSID of type {0} does not match the CLSID on PersistStreamTypeWrapper which is {1}.";
	public const string TargetObjectDoesNotSupportIPersistStream="Target object does not support IPersistStream.";
	public const string TargetTypeIsAnIntefaceButCorrespoindingTypeIsNotPersistStreamTypeWrapper="Target type is an interface but corresponding type is not PersistStreamTypeWrapper.";
	public const string NotAllowedPersistableCLSID="CLSID {0} is not allowed.";
	public const string TransferringToComplus="Transferring to ComPlus logical thread {0}.";
	public const string NamedArgsNotSupported="The cNamedArgs parameter is not supported and must be 0.";
	public const string MexBindingNotFoundInConfig="Binding '{0}' was not found in config. The config file must be present and contain a binding matching the one specified in the moniker.";
	public const string ClaimTypeCannotBeEmpty="The claimType cannot be an empty string.";
	public const string X509ChainIsEmpty="X509Chain does not have any valid certificates.";
	public const string MissingCustomCertificateValidator="X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.";
	public const string MissingMembershipProvider="UserNamePasswordValidationMode.MembershipProvider requires a MembershipProvider. Specify the MembershipProvider property.";
	public const string MissingCustomUserNamePasswordValidator="UserNamePasswordValidationMode.Custom requires a CustomUserNamePasswordValidator. Specify the CustomUserNamePasswordValidator property.";
	public const string SpnegoImpersonationLevelCannotBeSetToNone="The Security Support Provider Interface does not support Impersonation level 'None'. Specify Identification, Impersonation or Delegation level.";
	public const string PublicKeyNotRSA="The public key is not an RSA key.";
	public const string SecurityAuditFailToLoadDll="The '{0}' dynamic link library (dll) failed to load.";
	public const string SecurityAuditPlatformNotSupported="Writing audit messages to the Security log is not supported by the current platform. You must write audit messages to the Application log.";
	public const string NoPrincipalSpecifiedInAuthorizationContext="No custom principal is specified in the authorization context.";
	public const string AccessDenied="Access is denied.";
	public const string SecurityAuditNotSupportedOnChannelFactory="SecurityAuditBehavior is not supported on the channel factory.";
	public const string ExpiredTokenInChannelParameters="The Infocard token created during channel intialization has expired. Please create a new channel to reacquire token. ";
	public const string NoTokenInChannelParameters="No Infocard token was found in the ChannelParameters. Infocard requires that the security token be created during channel intialization.";
	public const string ArgumentOutOfRange="value must be >= {0} and <= {1}.";
	public const string InsufficientCryptoSupport="The binding's PeerTransportSecuritySettings can not be supported under the current system security configuration.";
	public const string InsufficientCredentials="Credentials specified are not sufficient to carry requested operation. Please specify a valid value for {0}. ";
	public const string UnexpectedSecurityTokensDuringHandshake="Connection was not accepted because the SecurityContext contained tokens that do not match the current security settings.";
	public const string InsufficientResolverSettings="Provided information is Insufficient to create a valid connection to the resolver service.";
	public const string InvalidResolverMode="Specified PeerResolverMode value {0} is invalid. Please specify either PeerResolveMode.Auto, Default, or Pnrp.";
	public const string MustOverrideInitialize="concrete PeerResolver implementation must override Initialize to accept metadata about resolver service.";
	public const string NotValidWhenOpen="The operation: {0} is not valid while the object is in open state.";
	public const string NotValidWhenClosed="The operation: {0} is not valid while the object is in closed state.";
	public const string DuplicatePeerRegistration="A peer registration with the service address {0} already exists.";
	public const string MessagePropagationException="The MessagePropagationFilter threw an exception. Please refer to InnerException.";
	public const string NotificationException="An event notification threw an exception. Please refer to InnerException.";
	public const string ResolverException="The Peer resolver threw an exception.  Please refer to InnerException.";
	public const string RefreshIntervalMustBeGreaterThanZero="Invalid RefreshInterval value of {0}; it must be greater than zero";
	public const string CleanupIntervalMustBeGreaterThanZero="Invalid CleanupInterval value of {0}; it must be greater than zero";
	public const string AmbiguousConnectivitySpec="Multiple link-local only interfaces detected.  Please specifiy the interface you require by using the ListenIpAddress attribute in the PeerTransportBindingElement";
	public const string MustRegisterMoreThanZeroAddresses="Registration with zero addresses detected.   Please call Register with more than zero addresses.";
	public const string BasicHttpContextBindingRequiresAllowCookie="BasicHttpContextBinding {0}:{1} requires that AllowCookies property is set to true.";
	public const string CallbackContextOnlySupportedInWSAddressing10="The message contains a callback context header with an endpoint reference for AddressingVersion '{0}'. Callback context can only be transmitted when the AddressingVersion is configured with 'WSAddressing10'.";
	public const string ListenAddressAlreadyContainsContext="The callback address already has a context header in it.";
	public const string MultipleContextHeadersFoundInCallbackAddress="The callback address contains multiple context headers. There can be at most one context header in a callback address.";
	public const string CallbackContextNotExpectedOnIncomingMessageAtClient="The incoming message with action '{0}' contains a callback context header with name '{1}' and namespace '{2}'. Callback context headers are not expected in incoming messages at the client.";
	public const string CallbackContextOnlySupportedInSoap="The message contains a callback context message property. Callback context can be transmitted only when the ContextBindingElement is configured with ContextExchangeMechanism of ContextSoapHeader.";
	public const string ContextBindingElementCannotProvideChannelFactory="ContextBindingElement cannot provide channel factory for the requested channel shape {0}.";
	public const string ContextBindingElementCannotProvideChannelListener="ContextBindingElement cannot provide channel listener for the requested channel shape {0}.";
	public const string InvalidCookieContent="Value '{0}' specified for 'name' attribute of ContextMessageProperty is either null or has invalid character(s). Please ensure value of 'name' is within the allowed value space.";
	public const string SchemaViolationInsideContextHeader="Context protocol was unable to parse the context header. Nodes disallowed by the context header schema were found inside the context header.";
	public const string CallbackContextNotExpectedOnOutgoingMessageAtServer="The outgoing message with action '{0}' contains a callback context message property. Callback context cannot be transmitted in outgoing messages at the server.";
	public const string ChannelIsOpen="Channel context management cannot be enabled or disabled after the channel is opened.";
	public const string ContextManagementNotEnabled="Context cached at the channel cannot be set or retrieved when the context management is disabled at the channel layer. Ensure context channel property 'IContextManager.Enabled' is set to true.";
	public const string CachedContextIsImmutable="Context cached at the channel layer cannot be changed after the channel is opened.";
	public const string InvalidMessageContext="Cannot specify 'ContextMessageProperty' in message when using context channel with context management enabled. Ensure the message does not have 'ContextMessageProperty' or disable context management by setting channel property 'IContextManager.Enabled' to false.";
	public const string InvalidContextReceived="Context channel received a message with context which does not match the current context cached at the channel. Ensure service does not change context after it was originally set or disable context management by setting channel property 'IContextManager.Enabled' to false.";
	public const string BehaviorRequiresContextProtocolSupportInBinding="Service behavior {0} requires that the binding associated with endpoint {1} listening on {2} supports the context protocol, because the contract associated with this endpoint may require a session. Currently configured binding for this endpoint does not support the context protocol. Please modify the binding to add support for the context protocol or modify the SessionMode on the contract to NotAllowed.";
	public const string HttpCookieContextExchangeMechanismNotCompatibleWithTransportType="Binding {1}:{2} is configured with ContextExchangeMechanism.HttpCookie which is not compatible with the transport type {0}. Please modify the ContextExchangeMechanism or use HTTP or HTTPS transport.";
	public const string HttpCookieContextExchangeMechanismNotCompatibleWithTransportCookieSetting="ContextBindingElement of binding {0}:{1} is configured with ContextExchangeMode.HttpCookie but the configuration of this binding's HttpTransportBindingElement prevents upper channel layers from managing cookies. Please set the HttpTransportBindingElement.AllowCookies property to false or change the ContextExchangeMechanism of ContextBindingElement to SoapHeader.";
	public const string PolicyImportContextBindingElementCollectionIsNull="ContextBindingElementImporter cannot import policy because PolicyImportContext.BindingElements collection is null.";
	public const string ContextChannelFactoryChannelCreatedDetail="EndpointAddress: {0}, Via:{1}";
	public const string XmlFormatViolationInContextHeader="Context protocol was unable to parse the context header.";
	public const string XmlFormatViolationInCallbackContextHeader="Context protocol was unable to parse the callback context header.";
	public const string OleTxHeaderCorrupt="The OLE Transactions header was invalid or corrupt.";
	public const string WsatHeaderCorrupt="The WS-AtomicTransaction header was invalid or corrupt.";
	public const string FailedToDeserializeIssuedToken="The issued token accompanying the WS-AtomicTransaction coordination context was invalid or corrupt.";
	public const string InvalidPropagationToken="The OLE Transactions propagation token received in the message could not be used to unmarshal a transaction. It may be invalid or corrupt.";
	public const string InvalidWsatExtendedInfo="The WS-AtomicTransaction extended information included in the OLE Transactions propagation token was invalid or corrupt.";
	public const string TMCommunicationError="An error occurred communicating with the distributed transaction manager.";
	public const string UnmarshalTransactionFaulted="The WS-AtomicTransaction protocol service could not unmarshal the flowed transaction. The following exception occured: {0}";
	public const string InvalidRegistrationHeaderTransactionId="The transaction identifier element in the registration header is invalid";
	public const string InvalidRegistrationHeaderIdentifier="The context identifier element in the registration header is invalid.";
	public const string InvalidRegistrationHeaderTokenId="The token identifier element in the registration header is invalid.";
	public const string InvalidCoordinationContextTransactionId="The transaction identifier element in the coordination context is invalid.";
	public const string WsatRegistryValueReadError="The WS-AtomicTransaction transaction formatter could not read the registry value '{0}'.";
	public const string WsatProtocolServiceDisabled="The MSDTC transaction manager's WS-AtomicTransaction protocol service '{0}' is disabled and cannot unmarshal incoming transactions.";
	public const string InboundTransactionsDisabled="The MSDTC transaction manager has disabled incoming transactions.";
	public const string SourceTransactionsDisabled="The incoming transaction cannot be unmarshaled because the source MSDTC transaction manager has either disabled outbound transactions or disabled its WS-AtomicTransaction protocol service.";
	public const string WsatUriCreationFailed="A registration service address could not be created from MSDTC whereabouts information.";
	public const string InvalidWsatProtocolVersion="The specified WSAT protocol version is invalid.";
	public const string ParameterCannotBeEmpty="The parameter cannot be empty.";
	public const string RedirectCache="The requested resouce has not changed and should be taken from cache.";
	public const string RedirectResource="The requested resource has moved to one of the following locations:\n{0}";
	public const string RedirectUseIntermediary="The requested resource must be accessed through one of the following intermediary service locations:\n{0}";
	public const string RedirectGenericMessage="The requested resource has been moved.";
	public const string RedirectMustProvideLocation="At least one RedirectionLocation must be provided for this RedirectionType.";
	public const string RedirectCacheNoLocationAllowed="RedirectionType 'Cache' does not allow any RedirectionLocation objects be passed into the constructor.";
	public const string RedirectionInfoStringFormatWithNamespace="{0} ({1})";
	public const string RedirectionInfoStringFormatNoNamespace="{0}";
	public const string RetryGenericMessage="The requested resource is available.";
	public const string ActivityCallback="Executing user callback.";
	public const string ActivityClose="Close '{0}'.";
	public const string ActivityConstructChannelFactory="Construct ChannelFactory. Contract type: '{0}'.";
	public const string ActivityConstructServiceHost="Construct ServiceHost '{0}'.";
	public const string ActivityExecuteMethod="Execute '{0}.{1}'.";
	public const string ActivityExecuteAsyncMethod="Execute Async: Begin: '{0}.{1}'; End: '{2}.{3}'.";
	public const string ActivityCloseChannelFactory="Close ChannelFactory. Contract type: '{0}'.";
	public const string ActivityCloseClientBase="Close ClientBase. Contract type: '{0}'.";
	public const string ActivityCloseServiceHost="Close ServiceHost '{0}'.";
	public const string ActivityListenAt="Listen at '{0}'.";
	public const string ActivityOpen="Open '{0}'.";
	public const string ActivityOpenServiceHost="Open ServiceHost '{0}'.";
	public const string ActivityOpenChannelFactory="Open ChannelFactory. Contract type: '{0}'.";
	public const string ActivityOpenClientBase="Open ClientBase. Contract type: '{0}'.";
	public const string ActivityProcessAction="Process action '{0}'.";
	public const string ActivityProcessingMessage="Processing message {0}.";
	public const string ActivityReceiveBytes="Receive bytes on connection '{0}'.";
	public const string ActivitySecuritySetup="Set up Secure Session.";
	public const string ActivitySecurityRenew="Renew Secure Session.";
	public const string ActivitySecurityClose="Close Security Session.";
	public const string ActivitySharedListenerConnection="Shared listener connection: '{0}'.";
	public const string ActivitySocketConnection="Socket connection: '{0}'.";
	public const string ActivityReadOnConnection="Reading data from connection on '{0}'.";
	public const string ActivityReceiveAtVia="Receiving data at via '{0}'.";
	public const string TraceCodeBeginExecuteMethod="Begin method execution.";
	public const string TraceCodeChannelCreated="Created: {0}";
	public const string TraceCodeChannelDisposed="Disposed: {0}";
	public const string TraceCodeChannelMessageSent="Sent a message over a channel";
	public const string TraceCodeChannelPreparedMessage="Prepared message for sending over a channel";
	public const string TraceCodeCommunicationObjectAborted="Aborted '{0}'.";
	public const string TraceCodeCommunicationObjectAbortFailed="Failed to abort {0}";
	public const string TraceCodeCommunicationObjectCloseFailed="Failed to close {0}";
	public const string TraceCodeCommunicationObjectClosed="Closed {0}";
	public const string TraceCodeCommunicationObjectCreated="Created {0}";
	public const string TraceCodeCommunicationObjectClosing="Closing {0}";
	public const string TraceCodeCommunicationObjectDisposing="Disposing {0}";
	public const string TraceCodeCommunicationObjectFaultReason="CommunicationObject faulted due to exception.";
	public const string TraceCodeCommunicationObjectFaulted="Faulted {0}";
	public const string TraceCodeCommunicationObjectOpenFailed="Failed to open {0}";
	public const string TraceCodeCommunicationObjectOpened="Opened {0}";
	public const string TraceCodeCommunicationObjectOpening="Opening {0}";
	public const string TraceCodeConfigurationIsReadOnly="The configuration is read-only.";
	public const string TraceCodeConfiguredExtensionTypeNotFound="Extension type is not configured.";
	public const string TraceCodeConnectionAbandoned="The connection has been abandoned.";
	public const string TraceCodeConnectToIPEndpoint="Connection information.";
	public const string TraceCodeConnectionPoolCloseException="An exception occurred while closing the connections in this connection pool.";
	public const string TraceCodeConnectionPoolIdleTimeoutReached="A connection has exceeded the idle timeout of this connection pool ({0}) and been closed.";
	public const string TraceCodeConnectionPoolLeaseTimeoutReached="A connection has exceeded the connection lease timeout of this connection pool ({0}) and been closed.";
	public const string TraceCodeConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached="MaxOutboundConnectionsPerEndpoint quota ({0}) has been reached, so connection was closed and not stored in this connection pool.";
	public const string TraceCodeServerMaxPooledConnectionsQuotaReached="MaxOutboundConnectionsPerEndpoint quota ({0}) has been reached, so the connection was closed and not reused by the listener.";
	public const string TraceCodeDefaultEndpointsAdded="No matching <service> tag was found. Default endpoints added.";
	public const string TraceCodeDiagnosticsFailedMessageTrace="Failed to trace a message";
	public const string TraceCodeDidNotUnderstandMessageHeader="Did not understand message header.";
	public const string TraceCodeDroppedAMessage="A response message was received, but there are no outstanding requests waiting for this message. The message is being dropped.";
	public const string TraceCodeCannotBeImportedInCurrentFormat="The given schema cannot be imported in this format.";
	public const string TraceCodeElementTypeDoesntMatchConfiguredType="The type of the element does not match the configuration type.";
	public const string TraceCodeEndExecuteMethod="End method execution.";
	public const string TraceCodeEndpointListenerClose="Endpoint listener closed.";
	public const string TraceCodeEndpointListenerOpen="Endpoint listener opened.";
	public const string TraceCodeErrorInvokingUserCode="Error invoking user code";
	public const string TraceCodeEvaluationContextNotFound="Configuration evaluation context not found.";
	public const string TraceCodeExportSecurityChannelBindingEntry="Starting Security ExportChannelBinding";
	public const string TraceCodeExportSecurityChannelBindingExit="Finished Security ExportChannelBinding";
	public const string TraceCodeExtensionCollectionDoesNotExist="The extension collection does not exist.";
	public const string TraceCodeExtensionCollectionIsEmpty="The extension collection is empty.";
	public const string TraceCodeExtensionCollectionNameNotFound="Extension element not associated with an extension collection.";
	public const string TraceCodeExtensionElementAlreadyExistsInCollection="The extension element already exists in the collection.";
	public const string TraceCodeExtensionTypeNotFound="Extension type not found.";
	public const string TraceCodeFailedToAddAnActivityIdHeader="Failed to set an activity id header on an outgoing message";
	public const string TraceCodeFailedToReadAnActivityIdHeader="Failed to read an activity id header on a message";
	public const string TraceCodeFilterNotMatchedNodeQuotaExceeded="Evaluating message logging filter against the message exceeded the node quota set on the filter.";
	public const string TraceCodeGetBehaviorElement="Get BehaviorElement.";
	public const string TraceCodeGetChannelEndpointElement="Get ChannelEndpointElement.";
	public const string TraceCodeGetCommonBehaviors="Get machine.config common behaviors.";
	public const string TraceCodeGetConfigurationSection="Get configuration section.";
	public const string TraceCodeGetConfiguredBinding="Get configured binding.";
	public const string TraceCodeGetDefaultConfiguredBinding="Get default configured binding.";
	public const string TraceCodeGetConfiguredEndpoint="Get configured endpoint.";
	public const string TraceCodeGetDefaultConfiguredEndpoint="Get default configured endpoint.";
	public const string TraceCodeGetServiceElement="Get ServiceElement.";
	public const string TraceCodeHttpAuthFailed="Authentication failed for HTTP(S) connection";
	public const string TraceCodeHttpActionMismatch="The HTTP SOAPAction header and the wsa:Action SOAP header did not match. ";
	public const string TraceCodeHttpChannelMessageReceiveFailed="Failed to lookup a channel to receive an incoming message. Either the endpoint or the SOAP action was not found.";
	public const string TraceCodeHttpChannelRequestAborted="Failed to send request message over HTTP";
	public const string TraceCodeHttpChannelResponseAborted="Failed to send response message over HTTP";
	public const string TraceCodeHttpChannelUnexpectedResponse="Received bad HTTP response";
	public const string TraceCodeHttpResponseReceived="HTTP response was received";
	public const string TraceCodeHttpChannelConcurrentReceiveQuotaReached="The HTTP concurrent receive quota was reached.";
	public const string TraceCodeHttpsClientCertificateInvalid="Client certificate is invalid.";
	public const string TraceCodeHttpsClientCertificateInvalid1="Client certificate is invalid with native error code {0} (see http://go.microsoft.com/fwlink/?LinkId=187517 for details).";
	public const string TraceCodeHttpsClientCertificateNotPresent="Client certificate is required.  No certificate was found in the request.  This might be because the client certificate could not be successfully validated by the operating system or IIS.  For information on how to bypass those validations and use a custom X509CertificateValidator in WCF please see http://go.microsoft.com/fwlink/?LinkId=208540.";
	public const string TraceCodeImportSecurityChannelBindingEntry="Starting Security ImportChannelBinding";
	public const string TraceCodeImportSecurityChannelBindingExit="Finished Security ImportChannelBinding";
	public const string TraceCodeIncompatibleExistingTransportManager="An existing incompatible transport manager was found for the specified URI.";
	public const string TraceCodeInitiatingNamedPipeConnection="Initiating Named Pipe connection.";
	public const string TraceCodeInitiatingTcpConnection="Initiating TCP connection.";
	public const string TraceCodeIssuanceTokenProviderBeginSecurityNegotiation="The IssuanceTokenProvider has started a new security negotiation.";
	public const string TraceCodeIssuanceTokenProviderEndSecurityNegotiation="The IssuanceTokenProvider has completed the security negotiation.";
	public const string TraceCodeIssuanceTokenProviderRedirectApplied="The IssuanceTokenProvider applied a redirection header.";
	public const string TraceCodeIssuanceTokenProviderRemovedCachedToken="The IssuanceTokenProvider removed the expired service token.";
	public const string TraceCodeIssuanceTokenProviderServiceTokenCacheFull="IssuanceTokenProvider pruned service token cache.";
	public const string TraceCodeIssuanceTokenProviderUsingCachedToken="The IssuanceTokenProvider used the cached service token.";
	public const string TraceCodeListenerCreated="Listener created";
	public const string TraceCodeListenerDisposed="Listener disposed";
	public const string TraceCodeMaxPendingConnectionsReached="Maximum number of pending connections has been reached. ";
	public const string TraceCodeMaxAcceptedChannelsReached="Maximum number of inbound session channel has been reached. ";
	public const string TraceCodeMessageClosed="A message was closed";
	public const string TraceCodeMessageClosedAgain="A message was closed again";
	public const string TraceCodeMessageCopied="A message was copied";
	public const string TraceCodeMessageCountLimitExceeded="Reached the limit of messages to log. Message logging is stopping. ";
	public const string TraceCodeMessageNotLoggedQuotaExceeded="Message not logged because its size exceeds configured quota";
	public const string TraceCodeMessageRead="A message was read";
	public const string TraceCodeMessageSent="Sent a message over a channel.";
	public const string TraceCodeMessageReceived="Received a message over a channel.";
	public const string TraceCodeMessageWritten="A message was written";
	public const string TraceCodeMessageProcessingPaused="Switched threads while processing a message.";
	public const string TraceCodeNegotiationAuthenticatorAttached="NegotiationTokenAuthenticator was attached.";
	public const string TraceCodeNegotiationTokenProviderAttached="NegotiationTokenProvider was attached.";
	public const string TraceCodeNoExistingTransportManager="No existing transport manager was found for the specified URI.";
	public const string TraceCodeOpenedListener="Transport is listening at base URI.";
	public const string TraceCodeOverridingDuplicateConfigurationKey="The configuration system has detected a duplicate key in a different configuration scope and is overriding with the more recent value.";
	public const string TraceCodePerformanceCounterFailedToLoad="A performance counter failed to load. Some performance counters will not be available.";
	public const string TraceCodePerformanceCountersFailed="Failed to load the performance counter '{0}'. Some performance counters will not be available";
	public const string TraceCodePerformanceCountersFailedDuringUpdate="There was an error while updating the performance counter '{0}'. This performance counter will be disabled.";
	public const string TraceCodePerformanceCountersFailedForService="Loading performance counters for the service failed. Performance counters will not be available for this service.";
	public const string TraceCodePerformanceCountersFailedOnRelease="Unloading the performance counters failed.";
	public const string TraceCodePrematureDatagramEof="A null Message (signalling end of channel) was received from a datagram channel, but the channel is still in the Opened state. This indicates a bug in the datagram channel, and the demuxer receive loop has been prematurely stalled. ";
	public const string TraceCodeRemoveBehavior="Behavior type already exists in the collection";
	public const string TraceCodeRequestChannelReplyReceived="Received reply over request channel";
	public const string TraceCodeSecurity="A failure occured while performing a security related operation.";
	public const string TraceCodeSecurityActiveServerSessionRemoved="An active security session was removed by the server.";
	public const string TraceCodeSecurityAuditWrittenFailure="A failure occurred while writing to the security audit log.";
	public const string TraceCodeSecurityAuditWrittenSuccess="The security audit log is written successfully.";
	public const string TraceCodeSecurityBindingIncomingMessageVerified="The security protocol verified the incoming message.";
	public const string TraceCodeSecurityBindingOutgoingMessageSecured="The security protocol secured the outgoing message.";
	public const string TraceCodeSecurityBindingSecureOutgoingMessageFailure="The security protocol cannot secure the outgoing message.";
	public const string TraceCodeSecurityBindingVerifyIncomingMessageFailure="The security protocol cannot verify the incoming message.";
	public const string TraceCodeSecurityClientSessionKeyRenewed="The client security session renewed the session key.";
	public const string TraceCodeSecurityClientSessionCloseSent="A Close message was sent by the client security session.";
	public const string TraceCodeSecurityClientSessionCloseResponseSent="Close response message was sent by client security session.";
	public const string TraceCodeSecurityClientSessionCloseMessageReceived="Close message was received by client security session.TraceCodeSecurityClientSessionKeyRenewed=Client security session renewed session key.";
	public const string TraceCodeSecurityClientSessionPreviousKeyDiscarded="The client security session discarded the previous session key.";
	public const string TraceCodeSecurityContextTokenCacheFull="The SecurityContextSecurityToken cache is full.";
	public const string TraceCodeSecurityIdentityDeterminationFailure="Identity cannot be determined for an EndpointReference.";
	public const string TraceCodeSecurityIdentityDeterminationSuccess="Identity was determined for an EndpointReference.";
	public const string TraceCodeSecurityIdentityHostNameNormalizationFailure="The HostName portion of an endpoint address cannot be normalized.";
	public const string TraceCodeSecurityIdentityVerificationFailure="Identity verification failed.";
	public const string TraceCodeSecurityIdentityVerificationSuccess="Identity verification succeeded.";
	public const string TraceCodeSecurityImpersonationFailure="Security impersonation failed at the server.";
	public const string TraceCodeSecurityImpersonationSuccess="Security Impersonation succeeded at the server.";
	public const string TraceCodeSecurityInactiveSessionFaulted="An inactive security session was faulted by the server.";
	public const string TraceCodeSecurityNegotiationProcessingFailure="Service security negotiation processing failure.";
	public const string TraceCodeSecurityNewServerSessionKeyIssued="A new security session key was issued by the server.";
	public const string TraceCodeSecurityPendingServerSessionAdded="A pending security session was added to the server.";
	public const string TraceCodeSecurityPendingServerSessionClosed="The pending security session was closed by the server.";
	public const string TraceCodeSecurityPendingServerSessionActivated="A pending security session was activated by the server.";
	public const string TraceCodeSecurityServerSessionCloseReceived="The server security session received a close message from the client.";
	public const string TraceCodeSecurityServerSessionCloseResponseReceived="Server security session received Close response message from client.";
	public const string TraceCodeSecurityServerSessionAbortedFaultSent="Server security session sent session aborted fault to client.";
	public const string TraceCodeSecurityServerSessionKeyUpdated="The security session key was updated by the server.";
	public const string TraceCodeSecurityServerSessionRenewalFaultSent="The server security session sent a key renewal fault to the client.";
	public const string TraceCodeSecuritySessionCloseResponseSent="The server security session sent a close response to the client.";
	public const string TraceCodeSecuritySessionServerCloseSent="Server security session sent Close to client.";
	public const string TraceCodeSecuritySessionAbortedFaultReceived="Client security session received session aborted fault from server.";
	public const string TraceCodeSecuritySessionAbortedFaultSendFailure="Failure sending security session aborted fault to client.";
	public const string TraceCodeSecuritySessionClosedResponseReceived="The client security session received a closed reponse from the server.";
	public const string TraceCodeSecuritySessionClosedResponseSendFailure="A failure occurred when sending a security session Close response to the client.";
	public const string TraceCodeSecuritySessionServerCloseSendFailure="Failure sending security session Close to client.";
	public const string TraceCodeSecuritySessionKeyRenewalFaultReceived="The client security session received a key renewal fault from the server.";
	public const string TraceCodeSecuritySessionRedirectApplied="The client security session was redirected.";
	public const string TraceCodeSecuritySessionRenewFaultSendFailure="A failure occurred when sending a renewal fault on the security session key to the client.";
	public const string TraceCodeSecuritySessionRequestorOperationFailure="The client security session operation failed.";
	public const string TraceCodeSecuritySessionRequestorOperationSuccess="The security session operation completed successfully at the client.";
	public const string TraceCodeSecuritySessionRequestorStartOperation="A security session operation was started at the client.";
	public const string TraceCodeSecuritySessionResponderOperationFailure="The security session operation failed at the server.";
	public const string TraceCodeSecuritySpnToSidMappingFailure="The ServicePrincipalName could not be mapped to a SecurityIdentifier.";
	public const string TraceCodeSecurityTokenAuthenticatorClosed="Security Token Authenticator was closed.";
	public const string TraceCodeSecurityTokenAuthenticatorOpened="Security Token Authenticator was opened.";
	public const string TraceCodeSecurityTokenProviderClosed="Security Token Provider was closed.";
	public const string TraceCodeSecurityTokenProviderOpened="Security Token Provider was opened.";
	public const string TraceCodeServiceChannelLifetime="ServiceChannel information.";
	public const string TraceCodeServiceHostBaseAddresses="ServiceHost base addresses.";
	public const string TraceCodeServiceHostTimeoutOnClose="ServiceHost close operation timedout.";
	public const string TraceCodeServiceHostFaulted="ServiceHost faulted.";
	public const string TraceCodeServiceHostErrorOnReleasePerformanceCounter="ServiceHost error on calling ReleasePerformanceCounters.";
	public const string TraceCodeServiceThrottleLimitReached="The system hit the limit set for throttle '{0}'. Limit for this throttle was set to {1}. Throttle value can be changed by modifying attribute '{2}' in serviceThrottle element or by modifying '{0}' property on behavior ServiceThrottlingBehavior.";
	public const string TraceCodeServiceThrottleLimitReachedInternal="The system hit an internal throttle limit. Limit for this throttle was set to {0}. This throttle cannot be configured.";
	public const string TraceCodeManualFlowThrottleLimitReached="The system hit the limit set for the '{0}' throttle. Throttle value can be changed by modifying {0} property on {1}.";
	public const string TraceCodeProcessMessage2Paused="Switched threads while processing a message for Contract '{0}' at Address '{1}'. ConcurrencyMode for service is set to Single/Reentrant and the service is currently processing another message.";
	public const string TraceCodeProcessMessage3Paused="Switched threads while processing a message for Contract '{0}' at Address '{1}'. Cannot process more than one transaction at a time and the transaction associated with the previous message is not yet complete. Ensure that the caller has committed the transaction.";
	public const string TraceCodeProcessMessage31Paused="Switched threads while processing a message for Contract '{0}' at Address '{1}'. Waiting for the completion of ReceiveContext acknowledgement. If your service seems to be not processing the message ensure that the channel implementation of receive context completes the operation.";
	public const string TraceCodeProcessMessage4Paused="Switched threads while processing a message for Contract '{0}' at Address '{1}'. UseSynchronizationContext property on ServiceBehaviorAttribute is set to true, and SynchronizationContext.Current was non-null when opening ServiceHost.  If your service seems to be not processing messages, consider setting UseSynchronizationContext to false.";
	public const string TraceCodeServiceOperationExceptionOnReply="Replying to an operation threw a exception.";
	public const string TraceCodeServiceOperationMissingReply="The Request/Reply operation {0} has no Reply Message.";
	public const string TraceCodeServiceOperationMissingReplyContext="The Request/Reply operation {0} has no IRequestContext to use for the reply.";
	public const string TraceCodeServiceSecurityNegotiationCompleted="Service security negotiation completed.";
	public const string TraceCodeSecuritySessionDemuxFailure="The incoming message is not part of an existing security session.";
	public const string TraceCodeServiceHostCreation="Create ServiceHost.";
	public const string TraceCodeSkipBehavior="Behavior type is not of expected type";
	public const string TraceCodeFailedAcceptFromPool="An attempt to reuse a pooled connection failed. Another attempt will be made with {0} remaining in the overall timeout.";
	public const string TraceCodeSystemTimeResolution="The operating system's timer resolution was detected as {0} ticks, which is about {1} milliseconds.";
	public const string TraceCodeRequestContextAbort="RequestContext aborted";
	public const string TraceCodeSharedManagerServiceEndpointNotExist="The shared memory for the endpoint of the service '{0}' does not exist. The service may not be started.";
	public const string TraceCodeSocketConnectionAbort="SocketConnection aborted";
	public const string TraceCodeSocketConnectionAbortClose="SocketConnection aborted under Close";
	public const string TraceCodeSocketConnectionClose="SocketConnection close";
	public const string TraceCodeSocketConnectionCreate="SocketConnection create";
	public const string TraceCodeSpnegoClientNegotiationCompleted="SpnegoTokenProvider completed SSPI negotiation.";
	public const string TraceCodeSpnegoServiceNegotiationCompleted="SpnegoTokenAuthenticator completed SSPI negotiation.";
	public const string TraceCodeSpnegoClientNegotiation="Client's outgoing SSPI negotiation.";
	public const string TraceCodeSpnegoServiceNegotiation="Service's outgoing SSPI negotiation.";
	public const string TraceCodeSslClientCertMissing="The remote SSL client failed to provide a required certificate.";
	public const string TraceCodeStreamSecurityUpgradeAccepted="The stream security upgrade was accepted successfully.";
	public const string TraceCodeTcpChannelMessageReceiveFailed="Failed to receive a message over TCP channel";
	public const string TraceCodeTcpChannelMessageReceived="Received a message over TCP channel";
	public const string TraceCodeUnderstoodMessageHeader="Understood message header.";
	public const string TraceCodeUnhandledAction="No service available to handle this action";
	public const string TraceCodeUnhandledExceptionInUserOperation="Unhandled exception in user operation '{0}.{1}'.";
	public const string TraceCodeWebHostFailedToActivateService="Webhost could not activate service";
	public const string TraceCodeWebHostFailedToCompile="Webhost couldn't compile service";
	public const string TraceCodeWmiPut="Setting a value via WMI.";
	public const string TraceCodeWsmexNonCriticalWsdlExportError="A non-critical error or warning occurred during WSDL Export";
	public const string TraceCodeWsmexNonCriticalWsdlImportError="A non-critical error or warning occurred in the MetadataExchangeClient during WSDL Import This could result in some endpoints not being imported.";
	public const string TraceCodeFailedToOpenIncomingChannel="An incoming channel was disposed because there was an error while attempting to open it.";
	public const string TraceCodeTransportListen="Listen at '{0}'.";
	public const string TraceCodeWsrmInvalidCreateSequence="An invalid create sequence message was received.";
	public const string TraceCodeWsrmInvalidMessage="An invalid WS-RM message was received.";
	public const string TraceCodeWsrmMaxPendingChannelsReached="An incoming create sequence request was rejected because the maximum pending channel count was reached.";
	public const string TraceCodeWsrmMessageDropped="A message in a WS-RM sequence has been dropped because it could not be buffered.";
	public const string TraceCodeWsrmReceiveAcknowledgement="WS-RM SequenceAcknowledgement received.";
	public const string TraceCodeWsrmReceiveLastSequenceMessage="WS-RM Last Sequence message received.";
	public const string TraceCodeWsrmReceiveSequenceMessage="WS-RM Sequence message received.";
	public const string TraceCodeWsrmSendAcknowledgement="WS-RM SequenceAcknowledgement sent.";
	public const string TraceCodeWsrmSendLastSequenceMessage="WS-RM Last Sequence message sent.";
	public const string TraceCodeWsrmSendSequenceMessage="WS-RM Sequence message sent.";
	public const string TraceCodeWsrmSequenceFaulted="A WS-RM sequence has faulted.";
	public const string TraceCodeChannelConnectionDropped="Channel connection was dropped";
	public const string TraceCodeAsyncCallbackThrewException="An async callback threw an exception!";
	public const string TraceCodeMetadataExchangeClientSendRequest="The MetadataExchangeClient is sending a request for metadata.";
	public const string TraceCodeMetadataExchangeClientReceiveReply="The MetadataExchangeClient received a reply.";
	public const string TraceCodeWarnHelpPageEnabledNoBaseAddress="The ServiceDebugBehavior Help Page is enabled at a relative address and cannot be created because there is no base address.";
	public const string TraceCodeTcpConnectError="The TCP connect operation failed.";
	public const string TraceCodeTxSourceTxScopeRequiredIsTransactedTransport="The transaction '{0}' was received for operation '{1}' from a transacted transport, such as MSMQ.";
	public const string TraceCodeTxSourceTxScopeRequiredIsTransactionFlow="The transaction '{0}' was flowed to operation '{1}'.";
	public const string TraceCodeTxSourceTxScopeRequiredIsAttachedTransaction="The transaction '{0}' was received for operation '{1}' from an InstanceContext transaction.";
	public const string TraceCodeTxSourceTxScopeRequiredUsingExistingTransaction="Existing transaction '{0}' being used for operation '{1}'.";
	public const string TraceCodeTxCompletionStatusCompletedForAutocomplete="The transaction '{0}' for operation '{1}' was completed due to the TransactionAutoComplete OperationBehaviorAttribute member being set to true.";
	public const string TraceCodeTxCompletionStatusCompletedForError="The transaction '{0}' for operation '{1}' was completed due to an unhandled execution exception.";
	public const string TraceCodeTxCompletionStatusCompletedForSetComplete="The transaction '{0}' for operation '{1}' was completed due to a call to SetTransactionComplete.";
	public const string TraceCodeTxCompletionStatusCompletedForTACOSC="The transaction '{0}' was completed when the session was closed due to the TransactionAutoCompleteOnSessionClose ServiceBehaviorAttribute member.";
	public const string TraceCodeTxCompletionStatusCompletedForAsyncAbort="The transaction '{0}' for operation '{1}' was completed due to asynchronous abort.";
	public const string TraceCodeTxCompletionStatusRemainsAttached="The transaction '{0}' for operation '{1}' remains attached to the InstanceContext.";
	public const string TraceCodeTxCompletionStatusAbortedOnSessionClose="The transaction '{0}' was aborted because it was uncompleted when the session was closed and the TransactionAutoCompleteOnSessionClose OperationBehaviorAttribute was set to false.";
	public const string TraceCodeTxReleaseServiceInstanceOnCompletion="The service instance was released on the completion of the transaction '{0}' because the ReleaseServiceInstanceOnTransactionComplete ServiceBehaviorAttribute was set to true.";
	public const string TraceCodeTxAsyncAbort="The transaction '{0}' was asynchronously aborted.";
	public const string TraceCodeTxFailedToNegotiateOleTx="The OleTransactions protocol negotiation failed for coordination context '{0}'.";
	public const string TraceCodeTxSourceTxScopeRequiredIsCreateNewTransaction="The transaction '{0}' for operation '{1}' was newly created.";
	public const string TraceCodeActivatingMessageReceived="Activating message received.";
	public const string TraceCodeDICPInstanceContextCached="InstanceContext cached for InstanceId {0}.";
	public const string TraceCodeDICPInstanceContextRemovedFromCache="InstanceContext for InstanceId {0} removed from cache.";
	public const string TraceCodeInstanceContextBoundToDurableInstance="DurableInstance's InstanceContext refcount incremented.";
	public const string TraceCodeInstanceContextDetachedFromDurableInstance="DurableInstance's InstanceContext refcount decremented.";
	public const string TraceCodeContextChannelFactoryChannelCreated="ContextChannel created.";
	public const string TraceCodeContextChannelListenerChannelAccepted="A new ContextChannel was accepted.";
	public const string TraceCodeContextProtocolContextAddedToMessage="Context added to Message.";
	public const string TraceCodeContextProtocolContextRetrievedFromMessage="Context retrieved from Message.";
	public const string TraceCodeWorkflowServiceHostCreated="WorkflowServiceHost created.";
	public const string TraceCodeServiceDurableInstanceDeleted="ServiceDurableInstance '{0}' deleted from persistence store.";
	public const string TraceCodeServiceDurableInstanceDisposed="ServiceDurableInstance '{0}' disposed.";
	public const string TraceCodeServiceDurableInstanceLoaded="ServiceDurableInstance loaded from persistence store.";
	public const string TraceCodeServiceDurableInstanceSaved="ServiceDurableInstance saved to persistence store.";
	public const string TraceCodeWorkflowDurableInstanceLoaded="WorkflowDurableInstance '{0}' loaded.";
	public const string TraceCodeWorkflowDurableInstanceActivated="WorkflowDurableInstance '{0}' activated.";
	public const string TraceCodeWorkflowDurableInstanceAborted="WorkflowDurableInstance aborted.";
	public const string TraceCodeWorkflowOperationInvokerItemQueued="Work item enqueued.";
	public const string TraceCodeWorkflowRequestContextReplySent="Reply sent for InstanceId {0}.";
	public const string TraceCodeWorkflowRequestContextFaultSent="Fault Sent for InstanceId {0}.";
	public const string TraceCodeSqlPersistenceProviderSQLCallStart="Sql execution started.";
	public const string TraceCodeSqlPersistenceProviderSQLCallEnd="Sql execution complete.";
	public const string TraceCodeSqlPersistenceProviderOpenParameters="SqlPersistenceProvider.Open() parameters.";
	public const string TraceCodeSyncContextSchedulerServiceTimerCancelled="SynchronizationContextWorkflowSchedulerService - Timer {0} cancelled.";
	public const string TraceCodeSyncContextSchedulerServiceTimerCreated="SynchronizationContextWorkflowSchedulerService - Timer {0} created for InstanceId {1}.";
	public const string TraceCodeSyndicationReadFeedBegin="Reading of a syndication feed started.";
	public const string TraceCodeSyndicationReadFeedEnd="Reading of a syndication feed completed.";
	public const string TraceCodeSyndicationReadItemBegin="Reading of a syndication item started.";
	public const string TraceCodeSyndicationReadItemEnd="Reading of a syndication item completed.";
	public const string TraceCodeSyndicationWriteFeedBegin="Writing of a syndication feed started.";
	public const string TraceCodeSyndicationWriteFeedEnd="Writing of a syndication feed completed.";
	public const string TraceCodeSyndicationWriteItemBegin="Writing of a syndication item started.";
	public const string TraceCodeSyndicationWriteItemEnd="Writing of a syndication item completed.";
	public const string TraceCodeSyndicationProtocolElementIgnoredOnWrite="Syndication element with name '{0}' and namespace '{1}' was not written.";
	public const string TraceCodeSyndicationProtocolElementInvalid="Syndication element with name '{0}' and namespace '{1}' is invalid.";
	public const string TraceCodeWebUnknownQueryParameterIgnored="HTTP query string parameter with name '{0}' was ignored.";
	public const string TraceCodeWebRequestMatchesOperation="Incoming HTTP request with URI '{0}' matched operation '{1}'.";
	public const string TraceCodeWebRequestDoesNotMatchOperations="Incoming HTTP request with URI '{0}' does not match any operation.";
	public const string UTTMustBeAbsolute="Parameter 'baseAddress' must an absolute uri.";
	public const string UTTBaseAddressMustBeAbsolute="BaseAddress must an absolute uri.";
	public const string UTTCannotChangeBaseAddress="Cannot change BaseAddress after calling MakeReadOnly.";
	public const string UTTMultipleMatches="There were multiple UriTemplateMatch results, but MatchSingle was called.";
	public const string UTTBaseAddressNotSet="BaseAddress has not been set. Set the BaseAddress property before calling MakeReadOnly, Match, or MatchSingle.";
	public const string UTTEmptyKeyValuePairs="KeyValuePairs must have at least one element.";
	public const string UTBindByPositionWrongCount="UriTemplate '{0}' contains {1} path variables and {2} query variables but {3} values were passed to the BindByPosition method. The number of values passed to BindByPosition should be greater than or equal to the number of path variables in the template and cannot be greater than the total number of variables in the template.";
	public const string UTBadBaseAddress="baseAddress must an absolute Uri.";
	public const string UTQueryNamesMustBeUnique="The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name' or of the form 'name=value', where each name is unique. Note that the names are case-insensitive. See the documentation for UriTemplate for more details.";
	public const string UTQueryCannotEndInAmpersand="The UriTemplate '{0}' is not valid; the query string cannot end with '&amp;'. See the documentation for UriTemplate for more details.";
	public const string UTQueryCannotHaveEmptyName="The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name' or of the form 'name=value'. See the documentation for UriTemplate for more details.";
	public const string UTVarNamesMustBeUnique="The UriTemplate '{0}' is not valid; the UriTemplate variable named '{1}' appears multiple times in the template. Note that UriTemplate variable names are case-insensitive. See the documentation for UriTemplate for more details.";
	public const string UTTAmbiguousQueries="UriTemplateTable does not support '{0}' and '{1}' since they are not equivalent, but cannot be disambiguated because they have equivalent paths and the same common literal values for the query string. See the documentation for UriTemplateTable for more detail.";
	public const string UTTOtherAmbiguousQueries="UriTemplateTable does not support multiple templates that have equivalent path as template '{0}' but have different query strings, where the query strings cannot all be disambiguated via literal values. See the documentation for UriTemplateTable for more detail.";
	public const string UTTDuplicate="UriTemplateTable (with allowDuplicateEquivalentUriTemplates = false) does not support both '{0}' and '{1}', since they are equivalent. Call MakeReadOnly with allowDuplicateEquivalentUriTemplates = true to use both of these UriTemplates in the same table. See the documentation for UriTemplateTable for more detail.";
	public const string UTInvalidFormatSegmentOrQueryPart="UriTemplate does not support '{0}' as a valid format for a segment or a query part.";
	public const string BindUriTemplateToNullOrEmptyPathParam="The path variable '{0}' in the UriTemplate must be bound to a non-empty string value.";
	public const string UTBindByPositionNoVariables="UriTemplate '{0}' contains no variables; yet the BindByPosition method was called with {1} values.";
	public const string UTCSRLookupBeforeMatch="UTCSR - Lookup was called before match";
	public const string UTDoesNotSupportAdjacentVarsInCompoundSegment="The UriTemplate '{0}' is not valid; UriTemplate does not support two adjacent variables with no literal in compound segments, such as in the segment '{1}'.";
	public const string UTQueryCannotHaveCompoundValue="The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name=value', when value cannot be a compound segment. See the documentation for UriTemplate for more details.";
	public const string UTQueryMustHaveLiteralNames="The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name' or of the form 'name=value', where name is a simple literal. See the documentation for UriTemplate for more details.";
	public const string UTAdditionalDefaultIsInvalid="Changing an inline default value with information from the additional default values is not supported; the default value to the variable '{0}' was already provided as part of the UriTemplate '{1}'. See the documentation for UriTemplate for more details.";
	public const string UTDefaultValuesAreImmutable="The default values of UriTemplate are immutable; they cannot be modified after the construction of the UriTemplate instance. See the documentation of UriTemplate for more details.";
	public const string UTDefaultValueToCompoundSegmentVar="The UriTemplate '{0}' is not valid; the UriTemplate compound path segment '{1}' provides a default value to variable '{2}'. Note that UriTemplate doesn't support default values to variables in compound segments. See the documentation for UriTemplate for more details.";
	public const string UTDefaultValueToQueryVar="The UriTemplate '{0}' is not valid; the UriTemplate variable declaration '{1}' provides a default value to query variable '{2}'. Note that UriTemplate doesn't support default values to query variables. See the documentation for UriTemplate for more details.";
	public const string UTInvalidDefaultPathValue="The UriTemplate '{0}' is not valid; the UriTemplate variable declaration '{1}' provides an empty default value to path variable '{2}'. Note that UriTemplate path variables cannot be bound to a null or empty value. See the documentation for UriTemplate for more details.";
	public const string UTInvalidVarDeclaration="The UriTemplate '{0}' is not valid; the UriTemplate variable declaration '{1}' isn't a valid variable construct. Note that UriTemplate variable definitions are either a simple, non-empty, variable name or a 'name=value' format, where the name must not be empty and the value provides a default value to the variable. See the documentation for UriTemplate for more details.";
	public const string UTInvalidWildcardInVariableOrLiteral="The UriTemplate '{0}' is not valid; the wildcard ('{1}') cannot appear in a variable name or literal, unless as a construct for a wildcard segment. Note that a wildcard segment, either a literal or a variable, is valid only as the last path segment in the template; the wildcard can appear only once. See the documentation for UriTemplate for more details.";
	public const string UTStarVariableWithDefaults="The UriTemplate '{0}' is not valid; the UriTemplate last path segment '{1}' provides a default value to final star variable '{2}'. Note that UriTemplate doesn't support default values to final star variable. See the documentation for UriTemplate for more details.";
	public const string UTDefaultValueToCompoundSegmentVarFromAdditionalDefaults="The UriTemplate '{0}' is not valid; the path variable '{1}', defined as part of a compound path segment has been provided with a default value as part of the additional defaults. Note that UriTemplate doesn't support default values to variables in compound segments. See the documentation for UriTemplate for more details.";
	public const string UTDefaultValueToQueryVarFromAdditionalDefaults="The UriTemplate '{0}' is not valid; the query variable '{1}' has been provided a default value as part of the additional defaults. Note that UriTemplate doesn't support default values to query variables. See the documentation for UriTemplate for more details.";
	public const string UTNullableDefaultAtAdditionalDefaults="The UriTemplate '{0}' is not valid; the additional default value '{1}' has a null value as default value. Note that null default values must be only provided to concrete path variables. See the documentation for UriTemplate for more details.";
	public const string UTNullableDefaultMustBeFollowedWithNullables="The UriTemplate '{0}' is not valid; the UriTemplate path variable '{1}' has a null default value while following path variable '{2}' has no defaults or provides a non-null default value. Note that UriTemplate path variable with null default value must be followed only with other path variables with null defaulted values. See the documentation for UriTemplate for more details.";
	public const string UTNullableDefaultMustNotBeFollowedWithLiteral="The UriTemplate '{0}' is not valid; the UriTemplate path variable '{1}' has a null default value while the following path segment '{2}' is not a variable segment with a null default value. Note that UriTemplate path variable with null default values must be followed only with other path variables with null defaulted value. See the documentation for UriTemplate for more details.";
	public const string UTNullableDefaultMustNotBeFollowedWithWildcard="The UriTemplate '{0}' is not valid; the UriTemplate path variable '{1}' has a null default value while the template is finished with a wildcard. Note that UriTemplate path variable with null default values must be followed only with other path variables with null defaulted value. See the documentation for UriTemplate for more details.";
	public const string UTStarVariableWithDefaultsFromAdditionalDefaults="The UriTemplate '{0}' is not valid; the UriTemplate final star variable '{1}' has been provides a default value as part of the additional defaults information. Note that UriTemplate doesn't support default values to final star variable. See the documentation for UriTemplate for more details.";
	public const string UTTInvalidTemplateKey="An invalid template '{0}' was passed as the key in a pair of template and its associated object. UriTemplateTable Key-Value pairs must always contain a valid UriTemplate object as key; note that UriTemplateTable doesn't support templates that are ignoring the trailing slash in respect to matching. See the documentation for UriTemplateTable for more details.";
	public const string UTTNullTemplateKey="A null UriTemplate was passed as the key in a pair of template and its associated object. UriTemplateTable Key-Value pairs must always contain a valid UriTemplate object as key. See the documentation for UriTemplateTable for more details.";
	public const string UTBindByNameCalledWithEmptyKey="The BindByName method of UriTemplate was called with an empty name in the collection of arguments for the bind. Note that the NameValueCollection or the Dictionary passed to BindByName cannot contain an empty (or null) name as a key. See the documentation of UriTemplate for more details.";
	public const string UTBothLiteralAndNameValueCollectionKey="The UriTemplate contains a literal value for query key '{0}', but that key also is present in the NameValueCollection. Either remove that key from the NameValueCollection, or else change the UriTemplate to not have a query literal for that key.";
	public const string ExtensionNameNotSpecified="The name of the extension element must be specified.";
	public const string UnsupportedRssVersion="The Rss20Serializer does not support RSS version '{0}'.";
	public const string Atom10SpecRequiresTextConstruct="The Atom10 specification requires '{0}' to have one of these values: \"text\", \"html\", \"xhtml\", however this value is '{1}' in the document being deserialized.";
	public const string ErrorInLine="Error in line {0} position {1}.";
	public const string ErrorParsingFeed="An error was encountered when parsing the feed's XML. Refer to the inner exception for more details.";
	public const string ErrorParsingDocument="An error was encountered when parsing the document's XML. Refer to the inner exception for more details.";
	public const string ErrorParsingItem="An error was encountered when parsing the item's XML. Refer to the inner exception for more details.";
	public const string ErrorParsingDateTime="An error was encountered when parsing a DateTime value in the XML.";
	public const string OuterElementNameNotSpecified="The outer element name must be specified.";
	public const string UnknownFeedXml="The element with name '{0}' and namespace '{1}' is not an allowed feed format.";
	public const string UnknownDocumentXml="The element with name '{0}' and namespace '{1}' is not an allowed document format.";
	public const string UnknownItemXml="The element with name '{0}' and namespace '{1}' is not an allowed item format.";
	public const string FeedFormatterDoesNotHaveFeed="The syndication feed formatter must be configured with a syndication feed.";
	public const string DocumentFormatterDoesNotHaveDocument="The document formatter must be configured with a document.";
	public const string ItemFormatterDoesNotHaveItem="The syndication item formatter must be configured with a syndication item.";
	public const string UnbufferedItemsCannotBeCloned="A feed containing items that are not buffered (i.e. the items are not stored in an IList) cannot clone its items. Buffer the items in the feed before calling Clone on it or pass false to the Clone method.";
	public const string FeedHasNonContiguousItems="The feed being deserialized has non-contiguous sets of items in it. This is not supported by '{0}'.";
	public const string FeedCreatedNullCategory="The feed created a null category.";
	public const string ItemCreatedNullCategory="The item created a null category.";
	public const string FeedCreatedNullPerson="The feed created a null person.";
	public const string ItemCreatedNullPerson="The item created a null person.";
	public const string FeedCreatedNullItem="=The feed created a null item.";
	public const string TraceCodeSyndicationFeedReadBegin="Reading of a syndication feed started.";
	public const string TraceCodeSyndicationFeedReadEnd="Reading of a syndication feed completed.";
	public const string TraceCodeSyndicationItemReadBegin="Reading of a syndication item started.";
	public const string TraceCodeSyndicationItemReadEnd="Reading of a syndication item completed.";
	public const string TraceCodeSyndicationFeedWriteBegin="Writing of a syndication feed started.";
	public const string TraceCodeSyndicationFeedWriteEnd="Writing of a syndication feed completed.";
	public const string TraceCodeSyndicationItemWriteBegin="Writing of a syndication item started.";
	public const string TraceCodeSyndicationItemWriteEnd="Writing of a syndication item completed.";
	public const string TraceCodeSyndicationProtocolElementIgnoredOnRead="Syndication XML node of type '{0}' with name '{1}' and namespace '{2}' ignored on read.";
	public const string TraceCodeSyndicationReadServiceDocumentBegin="Reading of a service document started.";
	public const string TraceCodeSyndicationReadServiceDocumentEnd="Reading of a service document completed.";
	public const string TraceCodeSyndicationWriteServiceDocumentBegin="Writing of a service document started.";
	public const string TraceCodeSyndicationWriteServiceDocumentEnd="Writing of a service document completed.";
	public const string TraceCodeSyndicationReadCategoriesDocumentBegin="Reading of a categories document started.";
	public const string TraceCodeSyndicationReadCategoriesDocumentEnd="Reading of a categories document completed.";
	public const string TraceCodeSyndicationWriteCategoriesDocumentBegin="Writing of a categories document started.";
	public const string TraceCodeSyndicationWriteCategoriesDocumentEnd="Writing of a categories document completed.";
	public const string FeedAuthorsIgnoredOnWrite="The feed's authors were not serialized as part of serializing the feed in RSS 2.0 format.";
	public const string FeedContributorsIgnoredOnWrite="The feed's contributors were not serialized as part of serializing the feed in RSS 2.0 format.";
	public const string FeedIdIgnoredOnWrite="The feed's id was not serialized as part of serializing the feed in RSS 2.0 format.";
	public const string FeedLinksIgnoredOnWrite="The feed's links were not serialized as part of serializing the feed in RSS 2.0 format.";
	public const string ItemAuthorsIgnoredOnWrite="The item's authors were not serialized as part of serializing the feed in RSS 2.0 format.";
	public const string ItemContributorsIgnoredOnWrite="The item's contributors were not serialized as part of serializing the feed in RSS 2.0 format.";
	public const string ItemLinksIgnoredOnWrite="The item's links were not serialized as part of serializing the feed in RSS 2.0 format.";
	public const string ItemCopyrightIgnoredOnWrite="The item's copyrights were not serialized as part of serializing the feed in RSS 2.0 format.";
	public const string ItemContentIgnoredOnWrite="The item's content was not serialized as part of serializing the feed in RSS 2.0 format.";
	public const string ItemLastUpdatedTimeIgnoredOnWrite="The item's last updated time was not serialized as part of serializing the feed in RSS 2.0 format.";
	public const string OuterNameOfElementExtensionEmpty="The outer name of the element extension cannot be empty.";
	public const string InvalidObjectTypePassed="The Type of object passed as parameter '{0}' is not derived from {1}. Ensure that the type of object passed is either of type {1} or derived from {1}.";
	public const string UnableToImpersonateWhileSerializingReponse="Failed to impersonate client identity during serialization of the response message.";
	public const string XmlLineInfo="Line {0}, position {1}.";
	public const string XmlFoundEndOfFile="end of file";
	public const string XmlFoundElement="element '{0}' from namespace '{1}'";
	public const string XmlFoundEndElement="end element '{0}' from namespace '{1}'";
	public const string XmlFoundText="text '{0}'";
	public const string XmlFoundCData="cdata '{0}'";
	public const string XmlFoundComment="comment '{0}'";
	public const string XmlFoundNodeType="node {0}";
	public const string XmlStartElementExpected="Start element expected. Found {0}.";
	public const string SingleWsdlNotGenerated="A single WSDL document could not be generated for this service. Multiple service contract namespaces were found ({0}). Ensure that all your service contracts have the same namespace.";
	public const string SFxDocExt_MainPageIntroSingleWsdl="You can also access the service description as a single file:";
	public const string TaskMethodParameterNotSupported="The use of '{0}' on the task-based asynchronous method is not supported.";
	public const string TaskMethodMustNotHaveOutParameter="Client side task-based asynchronous method must not have any out or ref parameters. Any data that would have been returned through an out or ref parameter should instead be returned as part of the TResult in the resulting task.";
	public const string SFxCannotImportAsParameters_OutputParameterAndTask="Generating message contract since the operation has multiple return values.";
	public const string ID0020="ID0020: The collection is empty.";
	public const string ID0023="ID0023: Failed to create an instance of '{0}' from configuration. A custom configuration element was specified, but the method LoadCustomConfiguration was not implemented. Override LoadCustomConfiguration to handle custom configuration loading.";
	public const string ID2004="ID2004: IAsyncResult must be the AsyncResult instance returned from the Begin call. The runtime is expecting '{0}', and the actual type is '{1}'.";
	public const string ID3002="ID3002: WSTrustServiceContract could not create a SecurityTokenService instance from WSTrustServiceContract.SecurityTokenServiceConfiguration.";
	public const string ID3004="ID3004: Cannot obtain the schema for namespace: '{0}'.";
	public const string ID3022="ID3022: The WSTrustServiceContract only supports receiving RequestSecurityToken messages. If you need to support more message types, override the WSTrustServiceContract.DispatchRequest method.";
	public const string ID3023="ID3023: The WSTrustServiceContract only supports receiving RequestSecurityToken messages asynchronously. If you need to support more message types, override the WSTrustServiceContract.BeginDispatchRequest and EndDispatchRequest.";
	public const string ID3097="ID3097: ServiceHost does not contain any valid Endpoints. Add at least one valid endpoint in the SecurityTokenServiceConfiguration.TrustEndpoints collection.";
	public const string ID3112="ID3112: Unrecognized RequestType '{0}' specified in the incoming request.";
	public const string ID3113="ID3113: The WSTrustServiceContract does not support receiving '{0}' messages with the '{1}' SOAP action. If you need to support this, override the ValidateDispatchContext method.";
	public const string ID3114="ID3114: The WSTrustServiceContract cannot deserialize the WS-Trust request.";
	public const string ID3137="ID3137: The TrustVersion '{0}', is not supported, only 'TrustVersion.WSTrust13' and 'TrustVersion.WSTrustFeb2005' is supported.";
	public const string ID3138="ID3138: The RequestSecurityTokenResponse that was received did not contain a SecurityToken.";
	public const string ID3139="ID3139: The WSTrustChannel cannot compute a proof key. The KeyType '{0}' is not supported. Valid proof key types supported by the WSTrustChannel are WSTrust13 and WSTrustFeb2005.";
	public const string ID3140="ID3140: Specify one or more BaseAddresses to enable metadata or set DisableWsdl to true in the SecurityTokenServiceConfiguration.";
	public const string ID3141="ID3141: The RequestType '{0}', is not supported. If you need to support this RequestType, override the corresponding virtual method in your SecurityTokenService derived class.";
	public const string ID3144="ID3144: The PortType '{0}' Operation '{1}' has Message '{2}' is expected to have only one part but contains '{3}'.";
	public const string ID3146="ID3146: WsdlEndpointConversionContext.WsdlPort cannot be null.";
	public const string ID3147="ID3147: WsdlEndpointConversionContext.WsdlPort.Service cannot be null.";
	public const string ID3148="ID3148: WsdlEndpointConversionContext.WsdlPort.Service.ServiceDescription cannot be null.";
	public const string ID3149="ID3149: Cannot find an input message type for PortType '({0}, {1})' for operation '{2}' in the given ServiceDescription.";
	public const string ID3150="ID3150: Cannot find an output message type for PortType '({0}, {1})' for operation '{2}' in the given ServiceDescription.";
	public const string ID3190="ID3190: The WSTrustChannel cannot compute a proof key without a valid SecurityToken set as the RequestSecurityToken.UseKey when the RequestSecurityToken.KeyType is '{0}'.";
	public const string ID3191="ID3191: The WSTrustChannel received a RequestedSecurityTokenResponse message containing an Entropy without a ComputedKeyAlgorithm.";
	public const string ID3192="ID3192: The WSTrustChannel cannot compute a proof key. The received RequestedSecurityTokenResponse does not contain a RequestedProofToken and the ComputedKeyAlgorithm specified in the response is not supported: '{0}'.";
	public const string ID3193="ID3193: The WSTrustChannel cannot compute a proof key. The received RequestedSecurityTokenResponse indicates that the proof key is computed using combined entropy. However, the response does not include an entropy.";
	public const string ID3194="ID3194: The WSTrustChannel cannot compute a proof key. The received RequestedSecurityTokenResponse indicates that the proof key is computed using combined entropy. However, the request does not include an entropy.";
	public const string ID3269="ID3269: Cannot determine the TrustVersion. It must either be specified explicitly, or a SecurityBindingElement must be present in the binding.";
	public const string ID3270="ID3270: The WSTrustChannel does not support multi-leg issuance protocols. The RSTR received from the STS must be enclosed in a RequestSecurityTokenResponseCollection element.";
	public const string ID3285="ID3285: The WS-Trust operation '{0}' is not valid or unsupported.";
	public const string ID3286="ID3286: The 'inner' parameter must implement the 'System.ServiceModel.Channels.IChannel' interface.";
	public const string ID3287="ID3287: WSTrustChannelFactory does not support changing the value of this property after a channel is created.";
	public const string ID4008="ID4008: '{0}' does not provide an implementation for '{1}'.";
	public const string ID4039="ID4039: A custom ServiceAuthorizationManager has been configured. Any custom ServiceAuthorizationManager must be derived from IdentityModelServiceAuthorizationManager.";
	public const string ID4041="ID4041: Cannot configure the ServiceHost '{0}'. The ServiceHost is in a bad state and cannot be configured.";
	public const string ID4053="ID4053: The token has WS-SecureConversation version '{0}'.  Version '{1}' was expected.";
	public const string ID4072="ID4072: The SecurityTokenHandler '{0}' registered for TokenType '{1}' must derive from '{2}'.";
	public const string ID4101="ID4101: The token cannot be validated because it is not a SamlSecurityToken or a Saml2SecurityToken. Token type: '{0}'";
	public const string ID4192="ID4192: The reader is not positioned on a KeyInfo element that can be read.";
	public const string ID4240="ID4240: The tokenRequirement must derived from 'RecipientServiceModelSecurityTokenRequirement' for SecureConversationSecurityTokens. The tokenRequirement is of type '{0}'.";
	public const string ID4244="ID4244: Internal error: sessionAuthenticator must support IIssuanceSecurityTokenAuthenticator.";
	public const string ID4245="ID4245: Internal error: sessionAuthenticator must support ICommunicationObject.";
	public const string ID4268="ID4268: MergeClaims must have at least one identity that is not null.";
	public const string ID4271="ID4271: No IAuthorizationPolicy was found for the Transport security token '{0}'.";
	public const string ID4274="ID4274: The Configuration property of this SecurityTokenHandler is set to null. Tokens cannot be read or validated in this state. Set this property or add this SecurityTokenHandler to a SecurityTokenHandlerCollection with a valid Configuration property.";
	public const string ID4285="ID4285: Cannot replace SecurityToken with Id '{0}' in cache with new one. Token must exist in cache to be replaced.";
	public const string ID4287="ID4287: The SecurityTokenRequirement '{0}' doesn't contain a ListenUri.";
	public const string ID5004="ID5004: Unrecognized namespace: '{0}'.";
	public const string TraceAuthorize="Authorize";
	public const string TraceOnAuthorizeRequestFailed="OnAuthorizeRequest Failed.";
	public const string TraceOnAuthorizeRequestSucceed="OnAuthorizeRequest Succeeded.";
	public const string AuthFailed="Authentication failed.";
	public const string DuplicateFederatedClientCredentialsParameters="The IssuedSecurityTokenProvider cannot support the FederatedClientCredentialsParameters. The FederatedClientCredentialsParameters has already provided the '{0}' parameter.";
	public const string UnsupportedTrustVersion="The TrustVersion '{0}', is not supported, only 'TrustVersion.WSTrust13' and 'TrustVersion.WSTrustFeb2005' is supported.";
	public const string InputMustBeDelegatingHandlerElementError="The input {0} must be a '{1}' object.";
	public const string InputTypeListEmptyError="The input handler list cannot be empty.";
	public const string DelegatingHandlerArrayHasNonNullInnerHandler="The '{0}' list is invalid because the property '{1}' of '{2}' is not null.";
	public const string DelegatingHandlerArrayFromFuncContainsNullItem="The '{0}' list created by the Func '{1}' is invalid because it contains one or more null items.";
	public const string HttpMessageHandlerFactoryConfigInvalid_WithBothTypeAndHandlerList="The config element '{0}' is invalid because the attribute '{1}' and the sub element '{2}' were both specified. These are mutually exclusive items and cannot be used simultaneouly.";
	public const string HttpMessageHandlerFactoryWithFuncCannotGenerateConfig="This '{0}' object cannot be used to generate configuration because it was created with the constructor that takes a '{1}' as the paramter.  This functionality is not supported through configuration files.  Please use a different constructor if you wish to generate a configuration file.";
	public const string HttpMessageHandlerTypeNotSupported="Invalid type: '{0}'. It must inherit from base type '{1}', cannot be abstract, and must expose a public default constructor.";
	public const string HttpMessageHandlerChannelFactoryNullPipeline="'{0}' cannot return a null '{1}' instance. Please ensure that '{0}' returns a valid '{1}' instance.";
	public const string HttpPipelineOperationCanceledError="HTTP pipeline operation cancelled.";
	public const string HttpPipelineMessagePropertyMissingError="The message property '{0}' is missing in the HttpRequestMessage. Please make sure this property not removed or changed from the properties of the HttpRequestMessage. If you are creating a new HttpRequestMessage, please copy this property from the old message to the new one.";
	public const string HttpPipelineMessagePropertyTypeError="The message property '{0}' inside the HttpRequestMessage is not with expected type '{1}'. Please make sure this property not removed or changed from the properties of the HttpRequestMessage. If you are creating a new HttpRequestMessage, please copy this property from the old message to the new one.";
	public const string InvalidContentTypeError="The value '{0}' is not a valid content type.";
	public const string HttpPipelineNotSupportedOnClientSide="The property '{0}' is not supported when building a ChannelFactory. The property value must be null when calling BuildChannelFactory.";
	public const string CanNotLoadTypeGotFromConfig="Cound not load type '{0}' from the assemblies in current AppDomain.";
	public const string HttpPipelineNotSupportNullResponseMessage="The HTTP response message should not be null. Please ensure your '{0}' instance returns a non-null '{1}' object.";
	public const string WebSocketInvalidProtocolNoHeader="The subprotocol '{0}' was not requested by the client - no '{1}' header was included in the request.";
	public const string WebSocketInvalidProtocolNotInClientList="The subprotocol '{0}' was not requested by the client. The client requested the following subprotocol(s): '{1}'.";
	public const string WebSocketInvalidProtocolInvalidCharInProtocolString="The subprotocol '{0}' is invalid because it contains the invalid character '{1}'.";
	public const string WebSocketInvalidProtocolContainsMultipleSubProtocolString="The value specified ('{0}') contains more than one subprotocol which is not supported.";
	public const string WebSocketInvalidProtocolEmptySubprotocolString="Empty string is not a valid subprotocol value. Please use \"null\" to specify no value.";
	public const string WebSocketOpaqueStreamContentNotSupportError="This method is not supported for this HTTP content.";
	public const string WebSocketElementConfigInvalidHttpMessageHandlerFactoryType="Invalid value for the {0} type. The type '{1}' does not derive from the appropriate base class '{2}' or is abstract.";
	public const string WebSocketEndpointOnlySupportWebSocketError="This service only supports WebSocket connections.";
	public const string WebSocketEndpointDoesNotSupportWebSocketError="This service does not support WebSocket connections.";
	public const string WebSocketUpgradeFailedError="WebSocket upgrade request failed. Received response status code '{0} ({1})', expected: '{2} ({3})'.";
	public const string WebSocketUpgradeFailedHeaderMissingError="WebSocket upgrade request failed. The header '{0}' is missing in the response.";
	public const string WebSocketUpgradeFailedWrongHeaderError="WebSocket upgrade request failed. The value of header '{0}' is '{1}'. The expected value is '{2}'.";
	public const string WebSocketUpgradeFailedInvalidProtocolError="Unexpected response - the server accepted the upgrade request but specified the subprotocol '{0}' when no subprotocol was requested.";
	public const string WebSocketContextWebSocketCannotBeAccessedError="WebSocket object cannot be accessed directly.";
	public const string WebSocketTransportError="A WebSocket error occurred.";
	public const string WebSocketUnexpectedCloseMessageError="Unexpected WebSocket close message received when receiving a message.";
	public const string WebSocketStreamWriteCalledAfterEOMSent="Cannot write to the stream because the end of the stream marker was already written.";
	public const string WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage="HttpChannelFactory cannot create the channel with shape '{0}' when the {1} of {2} was set as '{3}'.";
	public const string WebSocketMaxPendingConnectionsReached="Maximum number of pending WebSocket connections ({0}) has been reached. Consider increasing the '{1}' quota on the '{2}' property of the transport.";
	public const string WebSocketOpeningHandshakePropertiesNotAvailable="The opening handshake properties associated with the current WebSocket connection are not available. The most likely cause is that the property '{0}' on the '{1}' object returned from the custom '{2}' is not set.";
	public const string AcceptWebSocketTimedOutError="The operation to establish the WebSocket connection timed out. To increase this time limit, use the OpenTimeout property on the service endpoint's binding.";
	public const string TaskCancelledError="The task was cancelled.";
	public const string ClientWebSocketFactory_GetWebSocketVersionFailed="An error occured when getting the WebSocketVersion from the WebSocket factory of type '{0}'. See the inner exception for details.";
	public const string ClientWebSocketFactory_InvalidWebSocketVersion="The WebSocketVersion returned by the WebSocket factory of type '{0}' is either null, empty or invalid.";
	public const string ClientWebSocketFactory_CreateWebSocketFailed="An error occurred when creating the WebSocket with the factory of type '{0}'. See the inner exception for details.";
	public const string ClientWebSocketFactory_InvalidWebSocket="WebSocket creation failed. The '{0}' returned a WebSocket that is either null or not opened.";
	public const string ClientWebSocketFactory_InvalidSubProtocol="The WebSocket returned by the factory of type '{0}' has the SubProtocol '{1}' that doesn't match the requested SubProtocol value '{2}'.";
	public const string MultipleClientWebSocketFactoriesSpecified="The '{0}' contains multiple '{1}' objects, which is invalid. At most one '{1}' should be specified.";
	public const string WebSocketSendTimedOut="The Send operation timed out after '{0}'. Increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string WebSocketReceiveTimedOut="The Receive operation timed out after '{0}'. For duplex sessionful channels, the receive timeout is also the idle timeout for the channel, so consider setting a suitably large value for the ReceiveTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string WebSocketOperationTimedOut="The '{0}' operation timed out after '{1}'. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string WebSocketsServerSideNotSupported="This platform does not support server side WebSockets.";
	public const string WebSocketsClientSideNotSupported="This platform does not support client side WebSockets natively. Support for client side WebSockets can be enabled on this platform by providing an implementation of {0}.";
	public const string WebSocketsNotSupportedInClassicPipeline="WebSockets are not supported in the classic pipeline mode. Consider using the integrated pipeline mode for the application pool.";
	public const string WebSocketModuleNotLoaded="The WebSocketModule is not loaded. Check if the WebSocket feature is installed and the WebSocketModule is enabled in the list of IIS modules (see http://go.microsoft.com/fwlink/?LinkId=231398 for details).";
	public const string WebSocketTransportPolicyAssertionInvalid="The name of the policy being imported for contract '{0}:{1}' is invalid:'{2}'. It should be either '{3}', '{4}' or '{5}'.";
	public const string WebSocketVersionMismatchFromServer="The server didn't accept the connection request. It is possible that the WebSocket protocol version on your client doesn't match the one on the server('{0}').";
	public const string WebSocketSubProtocolMismatchFromServer="The server didn't accept the connection request. It is possible that the WebSocket subprotocol sent by your client is not supported by the server. Protocol(s) supported by the server are '{0}'.";
	public const string WebSocketContentTypeMismatchFromServer="The server didn't accept the connection request. It is possible that the client side message encoding format doesn't match the setting on the server side. Please check your binding settings.";
	public const string WebSocketContentTypeAndTransferModeMismatchFromServer="The server didn't accept the connection request. It is possible that the client side message encoding format or message transfer mode doesn't match the setting on the server side. Please check your binding settings.";
	public const string ResponseHeaderWithRequestHeadersCollection="This collection holds request headers and cannot contain the specified response header '{0}'.";
	public const string RequestHeaderWithResponseHeadersCollection="This collection holds response headers and cannot contain the specified request header '{0}'.";
	public const string MessageVersionNoneRequiredForHttpMessageSupport="Support for {0} and {1} can not be enabled with {2} when the {3} of the {4} is '{5}'.  Ensure the {4} used with the binding has a {3} of '{6}'. ";
	public const string WebHeaderEnumOperationCantHappen="Enumeration has either not started or has already finished.";
	public const string WebHeaderEmptyStringCall="The parameter '{0}' cannot be an empty string.";
	public const string WebHeaderInvalidControlChars="Specified value has invalid Control characters.";
	public const string WebHeaderInvalidCRLFChars="Specified value has invalid CRLF characters.";
	public const string WebHeaderInvalidHeaderChars="Specified value has invalid HTTP Header characters.";
	public const string WebHeaderInvalidNonAsciiChars="Specified value has invalid non-ASCII characters.";
	public const string WebHeaderArgumentOutOfRange="Specified argument was out of the range of valid values.";
	public const string CopyHttpHeaderFailed="Failed to copy the HTTP header '{0}' with value '{1}' to '{2}'.";
	public const string XmlInvalidConversion="The value '{0}' cannot be parsed as the type '{1}'.";
	public const string XmlInvalidStream="Stream returned by OperationStreamProvider cannot be null.";
	public const string LockTimeoutExceptionMessage="Cannot claim lock within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
	public const string InvalidEnumArgument="The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.";
	public const string InvalidTypedProxyMethodHandle="The specified method handle is incorrect for the proxy of type '{0}'";
	public const string FailedToCreateTypedProxy="Failed to create a typed proxy for type '{0}'";
	public const string Arg_SystemException="System error.";
	public const string SecurityTokenRequirementDoesNotContainProperty="The token requirement does not contain a property '{0}'.";
	public const string SecurityTokenRequirementHasInvalidTypeForProperty="The token requirement has an unexpected type '{1}' for property '{0}'. The expected property type is '{2}'.";
	public const string TokenCancellationNotSupported="The token provider '{0}' does not support token cancellation.";
	public const string TokenProviderUnableToGetToken="The token provider '{0}' was unable to provide a security token.";
	public const string TokenProviderUnableToRenewToken="The token provider '{0}' was unable to renew the security token.";
	public const string TokenRenewalNotSupported="The token provider '{0}' does not support token renewal.";
	public const string UserNameCannotBeEmpty="The username cannot be empty.";
	public const string ActivityBoundary="ActivityBoundary";
	public const string StringNullOrEmpty="StringNullOrEmpty";
	public const string GenericCallbackException="GenericCallbackException";
	public const string ArgumentCannotBeEmptyString="The argument must be a non-empty string.";
	public const string KeyIdentifierClauseDoesNotSupportKeyCreation="This SecurityKeyIdentifierClause does not support key creation.";
	public const string SymmetricKeyLengthTooShort="The length of the symmetric key specified is too short ({0} bytes).";
	public const string KeyIdentifierCannotCreateKey="This SecurityKeyIdentifier does not have any clause that can create a key.";
	public const string NoKeyIdentifierClauseFound="No clause of type '{0}' was found in the SecurityKeyIdentifier.";
	public const string LocalIdCannotBeEmpty="The localId cannot be empty. Specify a valid 'localId'.";
	public const string UnableToResolveKeyReference="The token resolver is unable to resolve the security key reference '{0}'.";
	public const string CannotValidateSecurityTokenType="The security token authenticator '{0}' cannot validate a token of type '{1}'.";
	public const string UnableToResolveTokenReference="The token resolver is unable to resolve the token reference '{0}'.";
	public const string UnauthorizedAccess_MemStreamBuffer="MemoryStream's internal buffer cannot be accessed.";
	public const string ConfigurationFilesNotSupported="Configuration files are not supported.";
	public const string X509ChainBuildFail="The X.509 certificate {0} chain building failed. The certificate that was used has a trust chain that cannot be verified. Replace the certificate or change the certificateValidationMode. {1}";
	public const string ImpersonationLevelNotSupported="The authentication modes using Kerberos do not support the impersonation level '{0}'. Specify identification or impersonation.";
	public const string ProvidedNetworkCredentialsForKerberosHasInvalidUserName="The NetworkCredentials provided for the Kerberos Token does not have a valid UserName.";
}
